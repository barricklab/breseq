#ifndef _BRESEQ_ERROR_COUNT_H_
#define _BRESEQ_ERROR_COUNT_H_

#include <string>
#include <vector>
#include <bam.h>

#include "breseq/pileup_base.h"

namespace breseq {
	
	/*! Count errors.
	 
	 \param bam is the read file generated by breseq.
	 \param fasta is the FASTA file that corresponds to the reference sequences; generates an FAI file as needed.
	 \param output_dir is the directory in which output files will be placed.
	 \param readfiles is a list of read files that were used to build the bam (do not include filename extension)
	 */
	void error_count(const std::string& bam, 
									 const std::string& fasta,
									 const std::string& output_dir,
									 const std::vector<std::string>& readfiles,
									 bool do_coverage,
                   bool do_errors);
	
	
	/*! Error-counting class.
	 
	 This class is used by the above error_count() function in order to count errors.
	 */
	class error_count_pileup : public breseq::pileup_base {
	public:
		typedef std::map<std::string,int> base_count_t;
		typedef std::map<uint8_t,base_count_t> qual_map_t;
		typedef std::map<int32_t,qual_map_t> fastq_map_t;
		
		typedef std::map<std::string,std::pair<double,double> > base_error_t; // basepair -> (error,correct) rates
		typedef std::map<uint8_t,base_error_t> error_map_t;
		typedef std::map<int32_t,error_map_t> fastq_error_map_t;
		
		//! Information that is tracked per-sequence.
		struct sequence_info {
			/*! Coverage count table.
			 
			 This is a table of non-deletion reads per position to non-redundancy counts.
			 For example, given unique_only_coverage[i] = x, for all aligned positions p:
			 i is the number of reads that do not indicate a deletion at p
			 x is the number of positions that have no redundancies
			 */
			std::vector<int> unique_only_coverage;
		};
		
		
		//! Constructor.
		error_count_pileup(const std::string& bam, const std::string& fasta, bool do_coverage=true, bool do_errors=true);
		
		//! Destructor.
		virtual ~error_count_pileup();		
		
		//! Called for each alignment.
		virtual void callback(const pileup& p);
		
		//! Print coverage distribution.
		void print_coverage(const std::string& output_dir);
		
		//! Print error file.
		void print_error(const std::string& output_dir, const std::vector<std::string>& readfiles);

		//! Load error rates.
		void load_error_rates(const std::string& input_dir, const std::vector<std::string>& readfiles);

		//! Return the correct rate for the given base pair, quality, and FASTQ file index.
		double log10_correct_rates(int32_t fastq_file_index, uint8_t quality, const std::string& base_key);
		
		//! Return the error rate for the given base pair, quality, and FASTQ file index.
		double log10_error_rates(int32_t fastq_file_index, uint8_t quality, const std::string& base_key);
		
	protected:		
		std::vector<sequence_info> _seq_info; //!< information about each sequence.
		fastq_map_t _error_hash; //!< fastq_file_index -> quality map.
		fastq_error_map_t _error_rates; //!< fastq_file_index -> quality -> error rate map.
		bool m_do_coverage;
    bool m_do_errors;
	};
	
} // breseq

#endif
