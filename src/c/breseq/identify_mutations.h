#ifndef _BRESEQ_IDENTIFY_MUTATIONS_H_
#define _BRESEQ_IDENTIFY_MUTATIONS_H_

#include <string>
#include <vector>
#include <fstream>
#include <cmath>
#include <boost/optional.hpp>

#include "breseq/error_count.h"
#include "breseq/genome_diff.h"
#include "breseq/pileup_base.h"

namespace breseq {
	
	/*! Calculate errors in the given BAM file based on reference FAI files.
	 
	 \param bam is the read file generated by breseq.
	 \param fastas is the list of FASTA files that correspond to the reference sequences; generates FAI files as needed.
	 \param output_dir is the directory in which output files will be placed.
	 \param readfiles is a list of read files that were used to build the bam (do not include filename extension)
	 */
	void identify_mutations(const std::string& bam,
													const std::string& fasta,
													const std::string& error_dir,
													const std::string& gd_file,
													const std::string& output_dir,
													const std::vector<std::string>& readfiles,
													const std::string& coverage_dir,
                          const std::vector<double>& deletion_propagation_cutoff,
													double mutation_cutoff,
													bool predict_deletions,
													bool predict_polymorphisms,
                          uint8_t min_qual_score);
	
	
	/*! Position information struct.
	 
	 Note: The "triples" in this struct are to be indexed via the strand, which is
	 either +1 or -1.  As a result, use 1-based indexing, e.g.: unique_cov[1+strand].
	 */
	struct position_info {
		//! Constructor.
		position_info() {
			bzero(this,sizeof(position_info));
		}
		
		int unique_cov[3];
		int unique_trimmed_cov[3];
		int mutation_cov[3];
	};
	
	
	/*! Position coverage struct.
	 
	 Note: The "triples" in this struct are to be indexed via the strand, which is
	 either +1 or -1.  As a result, use 1-based indexing, e.g.: unique_cov[1+strand].
	 Additionally, we use the 1th element as the total field for both strands.
	 */
	struct position_coverage {
		//! Constructor.
		position_coverage() {
			bzero(this,sizeof(position_coverage));
		}

		//! Constructor.
		position_coverage(double v) {
			bzero(this,sizeof(position_coverage));
			unique[0] = v; unique[1] = v; unique[2] = v;
			redundant[0] = v; redundant[1] = v; redundant[2] = v;
		}
		
		position_coverage& operator=(const position_coverage& that) {
			if(this != &that) {
				memcpy(this, &that, sizeof(that));
			}
			return *this;
		}
		
		//! Sum the position coverage fields.
		void sum() {
			unique[1] = unique[0]+unique[2];
			redundant[1] = redundant[0]+redundant[2];
			raw_redundant[1] = raw_redundant[0]+raw_redundant[2];
			total = unique[1] + round(redundant[1]);
		}
		
		double unique[3];
		double redundant[3];
		int raw_redundant[3];
		int total;
	};
	

	/*! Polymorphism data struct.
	 */
	struct polymorphism_data {
		//! Constructor.
		polymorphism_data(uint8_t b, uint8_t q, int s, int32_t f)
		: base(b), quality(q), strand(s), fastq_file_index(f) {
		}
		
		uint8_t base;
		uint8_t quality;
		int strand;
		int32_t fastq_file_index;
	};
	
	
	/*! Error-counting class.
	 
	 This class is used by the above identify_mutations() function in order to count errors.
	 */
	class identify_mutations_pileup : public breseq::pileup_base {
	public:
		typedef std::map<std::string,int> base_count_t;
		typedef std::map<uint8_t,base_count_t> qual_map_t;
		typedef std::map<int32_t,qual_map_t> fastq_map_t;
		
		
		
		//! Information that is tracked per-sequence.
		struct sequence_info {
			/*! Coverage count table.
			 
			 This is a table of non-deletion reads per position to non-redundancy counts.
			 For example, given unique_only_coverage[i] = x, for all aligned positions p:
			 i is the number of reads that do not indicate a deletion at p
			 x is the number of positions that have no redundancies
			 */
			std::vector<int> unique_only_coverage;
		};
		
		struct shared_info {
			shared_info() : coverage_unique_total(0), coverage_unique_uncalled(0), coverage_unique_called(0) { }
			int coverage_unique_total;
			int coverage_unique_uncalled;
			int coverage_unique_called;
		};
		
		
		//! Constructor.
		identify_mutations_pileup(const std::string& bam, 
															const std::string& fasta,
															const std::string& error_dir,
															const std::string& gd_file,
															const std::string& output_dir,
															const std::vector<std::string>& readfiles,
															const std::string& coverage_dir,
															const std::vector<double>& deletion_propagation_cutoff,
															double mutation_cutoff,
															bool predict_deletions,
															bool predict_polymorphisms,
                              uint8_t min_qual_score);
				
		//! Destructor.
		virtual ~identify_mutations_pileup();		
		
		//! Called for each alignment.
		virtual void callback(const pileup& p);
		
		//! Called at the end of the pileup.
		virtual void at_end(uint32_t tid, uint32_t seqlen);
		
	protected:
		//! Helper method to track deletions.
		void check_deletion_completion(uint32_t position, uint32_t seq_id, const position_coverage* this_position_coverage, double e_value_call);

		//! Helper method to track unknowns.
		void update_unknown_intervals(uint32_t position, uint32_t seq_id, bool base_predicted, bool this_position_unique_only_coverage);
		
		error_count_results _ecr; //!< Error count results.
		genome_diff _gd; //!< Genome diff.
    uint8_t _min_qual_score; //!< minimum quality score to count base for RA
		double _deletion_seed_cutoff;
		std::vector<double> _deletion_propagation_cutoff; //!< Coverage above which deletions are cutoff.
		double _mutation_cutoff; //!< log10 e-value cutoff value for mutation predictions.
		bool _predict_deletions; //!< Whether to predict mutations.
		bool _predict_polymorphisms; //!< Whether to predict polymorphisms.
		const std::string _coverage_dir; //!< Directory in which to store coverage data.
		double _log10_ref_length; //!< log10 of the total reference sequence.
		std::vector<sequence_info> _seq_info; //!< information about each sequence.
		fastq_map_t error_hash; //!< fastq_file_index -> quality map.
		shared_info s; // summary stats
		
		// this is used to output coverage data:
		std::ofstream _coverage_data;
		
		// these are state variables used by the deletion-prediction method.
    boost::optional<uint32_t> _on_deletion_seq_id;
		double _this_deletion_propagation_cutoff;
		boost::optional<uint32_t> _last_deletion_start_position;
		boost::optional<uint32_t> _last_deletion_end_position;
		boost::optional<uint32_t> _last_deletion_redundant_start_position;
    boost::optional<uint32_t> _last_deletion_redundant_end_position;
		bool _this_deletion_reaches_seed_value;
    bool _this_deletion_redundant_reached_zero;
		uint32_t _last_position_coverage_printed;
		boost::optional<position_coverage> _left_outside_coverage_item;
		boost::optional<position_coverage> _left_inside_coverage_item;
		boost::optional<position_coverage> _last_position_coverage;
    
		// these are state variables used by the unknown prediction method.
		boost::optional<uint32_t> _last_start_unknown_interval;
	};
	
} // breseq

#endif
