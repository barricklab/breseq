#!/usr/bin/env perl

###
# Pod Documentation
###

=head1 NAME

fastq_utils

=head1 SYNOPSIS

Usage: fastq_utils COMMAND [arguments]

Performs various functions on FASTQ formatted files. Options depend on the COMMAND supplied.

=head1 Command: FORMAT

Usage: fastq_utils FORMAT [-n 1000|ALL] input.fastq

Examine reads in a FASTQ file to predict its base quality score format.

=over

=item B<-n> <int>, B<-n> ALL, B<--num>=<int>, B<--num>=ALL 

Number of reads to examine when predicting the format. The keyword 'ALL' means to examine every read in input the file.

=item B<input.fastq>

FASTQ file to examine.

=back

=head1 Command: SANGER

=over

Usage: fastq_utils SANGER -f from_format [-l] input.fastq output.fastq

Convert a FASTQ file to SANGER format.

=item B<-f> <format>, B<--format>=<format>

Base quality score format of the input FASTQ file. Valid formats are: 
SANGER, SOLEXA, ILLUMINA_1.3+, ILLUMINA_1.5+. If you are unsure of the format, use the FORMAT command.

=item B<-l>, B<--list-format>

In the input FASTQ file, quality score lines are white space separated numbers, rather than character strings. 

=item B<input.fastq>

Input FASTQ file in specified format.

=item B<output.fastq>

Output FASTQ file in SANGER format.

=back

=head1 AUTHOR

Jeffrey E. Barrick <jeffrey.e.barrick@gmail.com>

=head1 LICENSE

Copyright (C) 2010 Michigan State University.

This is free software; you can redistribute it and/or modify it under the terms the 
GNU General Public License as published by the Free Software Foundation; either 
version 1, or (at your option) any later version.

=cut

###
# End Pod Documentation
###


use strict;
use Data::Dumper;
use Getopt::Long;

use FindBin;
use lib $FindBin::Bin;

#### Paths to Locally Installed Modules ####
use Config;
use lib $FindBin::Bin . "/../lib/perl5";
use lib $FindBin::Bin . "/../lib/perl5/site_perl";
use lib $FindBin::Bin . "/../lib/perl5/$Config{archname}";

my ($help, $man);
my $verbose;
my $mode;
GetOptions(
	'help|?' => \$help, 'man' => \$man,
	'mode|m' => \$mode		
);
pod2usage(1) if $help;
(1) or pod2usage(1);	
pod2usage(-exitstatus => 0, -verbose => 2) if $man;

my ($input, $output) =  @ARGV;

open IN, "<$input" or die;
open OUT, ">$output" or die;

my $line_no = 1;

while (my $_ = <IN>) {
	chomp $_;
	
	next if ($_ =~ m/^@/);
	
	my @ll = split /\t/, $_;
	
	#print "line_no: $line_no\n";
	
	my ($len, $start, $end) = cigar2len($ll[5]);
	
	#print "$len, $start, $end\n";
	
	#move quality over
	foreach my $item (@ll) {
		if ($item =~ m/^CQ:Z:(.+)/) {
			
			my $q = $1;
			#reverse strand
			if ($ll[1] == 16) {
				$q = reverse($q);
				$start = $len - $start + 1;
				$end = $len - $end + 1;
				($start, $end) = ($end, $start);
			}
			$ll[10] = substr($q, $start-1, $end-$start+1);
		}
	}
	
	if ($mode) {
		$ll[0] .= (($len == 50) ? "_1" : "_2" )
	}

	print OUT +join("\t", @ll) . "\n";
	$line_no++;
}


sub cigar2len
{
	my ($cigar) = @_;
	my $len = 0;
	my $start = 1;
	my $op_num=0;
	my $last_op;
	my $last_len;
	while ($cigar =~ s/(\d+)([HIDSM])//) {
		$len += $1 if ($2 ne 'D');
		$start += $1 if (($op_num == 0) && ($2 eq 'H'));
		$last_op = $2;
		$last_len = $1;
		$op_num++;
	}
	
	my $end=$len;
	$end-= $last_len if ($last_op eq 'H');
	
	return ($len, $start, $end);
}