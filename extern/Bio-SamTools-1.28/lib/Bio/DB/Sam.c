/*
 * This file was generated automatically by ExtUtils::ParseXS version 2.21 from the
 * contents of Sam.xs. Do not edit this file, edit Sam.xs instead.
 *
 *	ANY CHANGES MADE HERE WILL BE LOST! 
 *
 */

#line 1 "lib/Bio/DB/Sam.xs"
#ifdef PERL_CAPI
#define WIN32IO_IS_STDIO
#endif
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"
#ifdef FCGI
 #include <fcgi_stdio.h>
#else
 #ifdef USE_SFIO
  #include <config.h>
 #else
  #include <stdio.h>
 #endif
 #include <perlio.h>
#endif

#include <unistd.h>
#include <math.h>
#include "bam.h"
#include "khash.h"
#include "faidx.h"

/* stolen from bam_aux.c */
#define MAX_REGION 1<<29

typedef tamFile         Bio__DB__Tam;
typedef faidx_t*        Bio__DB__Sam__Fai;
typedef bamFile         Bio__DB__Bam;
typedef bam_header_t*   Bio__DB__Bam__Header;
typedef bam1_t*         Bio__DB__Bam__Alignment;
typedef bam_index_t*    Bio__DB__Bam__Index;
typedef bam_pileup1_t*  Bio__DB__Bam__Pileup;
typedef struct {
  SV* callback;
  SV* data;
} fetch_callback_data;
typedef fetch_callback_data *fetch_callback_dataptr;
typedef struct {
  int    start;
  int    end;
  double width;
  int    reads;
  int*   bin;
} coverage_graph;
typedef coverage_graph *coverage_graph_ptr;

void XS_pack_charPtrPtr( SV * arg, char ** array, int count) {
  int i;
  AV * avref;
  avref = (AV*)sv_2mortal((SV*)newAV());
  for (i=0; i<count; i++) {
    av_push(avref, newSVpv(array[i], strlen(array[i])));
  }
  SvSetSV( arg, newRV((SV*)avref));
}

int bam_fetch_fun (const bam1_t *b, void *data) {
  dSP;
  int count;

  fetch_callback_dataptr fcp;
  SV* callback;
  SV* callbackdata;
  SV* alignment_obj;
  bam1_t *b2;

  fcp          = (fetch_callback_dataptr) data;
  callback     = fcp->callback;
  callbackdata = fcp->data;

  /* turn the bam1_t into an appropriate object */
  /* need to dup it here so that the C layer doesn't reuse the address under Perl */
  b2 = bam_dup1(b);

  alignment_obj = sv_setref_pv(newSV(sizeof(bam1_t)),"Bio::DB::Bam::Alignment",(void*) b2);

  /* set up subroutine stack for the call */
  ENTER;
  SAVETMPS;

  PUSHMARK(SP);
  XPUSHs(sv_2mortal(alignment_obj));
  XPUSHs(callbackdata);
  PUTBACK;

  /* execute the call */
  count = call_sv(callback,G_SCALAR|G_DISCARD);

  FREETMPS;
  LEAVE;

  return 1;
}

int invoke_pileup_callback_fun(uint32_t tid, 
			       uint32_t pos, 
			       int n, 
			       const bam_pileup1_t *pl,
			       void *data) {
  dSP;
  int count,i;
  fetch_callback_dataptr fcp;
  SV*  callback;
  SV*  callbackdata;
  SV*  pileup_obj;
  SV* p;
  SV** pileups;
  AV*  pileup;

  fcp          = (fetch_callback_dataptr) data;
  callback     = fcp->callback;
  callbackdata = fcp->data;

  /* turn the bam_pileup1_t into the appropriate object */
  /* this causes a compiler warning -- ignore it */
 if (0) {
  Newxz(pileups,n,SV*);
  for (i=0;i<n;i++)
        pileups[i] = sv_setref_pv(sv_2mortal(newSV(sizeof(bam_pileup1_t))),
			      "Bio::DB::Bam::Pileup",
			      (void*) &pl[i]);
  pileup = av_make(n,pileups);
  Safefree(pileups);
} else {
  pileup = newAV();
  av_extend(pileup,n);
  for (i=0;i<n;i++) {
    p = newSV(sizeof(bam_pileup1_t));	
    sv_setref_pv(p,"Bio::DB::Bam::Pileup",(void*) &pl[i]);
    av_push(pileup,p);
  } 
}
  
    /* set up subroutine stack for the call */
  ENTER;
  SAVETMPS;

  PUSHMARK(SP);
  XPUSHs(sv_2mortal(newSViv(tid)));
  XPUSHs(sv_2mortal(newSViv(pos)));
  XPUSHs(sv_2mortal(newRV_noinc((SV*)pileup)));
  XPUSHs(callbackdata);
  PUTBACK;

  /* execute the call */
  count = call_sv(callback,G_SCALAR|G_DISCARD);

  FREETMPS;
  LEAVE;
}

int add_pileup_line (const bam1_t *b, void *data) {
  bam_plbuf_t *pileup = (bam_plbuf_t*) data;
  bam_plbuf_push(b,pileup);
  return 0;
}

int add_lpileup_line (const bam1_t *b, void *data) {
  bam_lplbuf_t *pileup = (bam_lplbuf_t*) data;
  bam_lplbuf_push(b,pileup);
  return 0;
}

int coverage_from_pileup_fun (uint32_t tid, 
			      uint32_t pos, 
			      int n, 
			      const bam_pileup1_t *pl, 
			      void *data) {
  coverage_graph_ptr  cgp;
  int                 bin;
  int                 i;
  int                 valid;

  cgp = (coverage_graph_ptr) data;
  cgp->reads += n;

  valid = 0;
  for (i=0;i<n;i++) {
    if (!pl[i].is_del && !pl[i].is_refskip)
        valid++;
  }

  if (n > 0 && pos >= cgp->start && pos <= cgp->end) {
    bin = (pos-cgp->start)/cgp->width;
    cgp->bin[bin] += valid;
  }

  return 0;
}

#line 202 "lib/Bio/DB/Sam.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
            Perl_croak(aTHX_ "Usage: %s::%s(%s)", hvname, gvname, params);
        else
            Perl_croak(aTHX_ "Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
        Perl_croak(aTHX_ "Usage: CODE(0x%"UVxf")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#ifdef PERL_IMPLICIT_CONTEXT
#define croak_xs_usage(a,b)	S_croak_xs_usage(aTHX_ a,b)
#else
#define croak_xs_usage		S_croak_xs_usage
#endif

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#line 254 "lib/Bio/DB/Sam.c"

XS(XS_Bio__DB__Tam_open); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__Tam_open)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "packname=\"Bio::DB::Tam\", filename");
    {
	char *	packname;
	char *	filename = (char *)SvPV_nolen(ST(1));
	Bio__DB__Tam	RETVAL;

	if (items < 1)
	    packname = "Bio::DB::Tam";
	else {
	    packname = (char *)SvPV_nolen(ST(0));
	}
#line 200 "lib/Bio/DB/Sam.xs"
    RETVAL = sam_open(filename);
#line 278 "lib/Bio/DB/Sam.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Bio::DB::Tam", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__Tam_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__Tam_DESTROY)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "tam");
    {
	Bio__DB__Tam	tam;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    tam = INT2PTR(Bio__DB__Tam,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not a reference",
			"Bio::DB::Tam::DESTROY",
			"tam");
#line 209 "lib/Bio/DB/Sam.xs"
     sam_close(tam);
#line 309 "lib/Bio/DB/Sam.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Bio__DB__Tam_header_read2); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__Tam_header_read2)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "packname=\"Bio::DB::Tam\", filename");
    {
	char *	packname;
	char *	filename = (char *)SvPV_nolen(ST(1));
	Bio__DB__Bam__Header	RETVAL;

	if (items < 1)
	    packname = "Bio::DB::Tam";
	else {
	    packname = (char *)SvPV_nolen(ST(0));
	}
#line 217 "lib/Bio/DB/Sam.xs"
      RETVAL = sam_header_read2(filename);
#line 337 "lib/Bio/DB/Sam.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Bio::DB::Bam::Header", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__Tam_header_read); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__Tam_header_read)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "tam");
    {
	Bio__DB__Tam	tam;
	Bio__DB__Bam__Header	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::Tam")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    tam = INT2PTR(Bio__DB__Tam,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::Tam::header_read",
			"tam", "Bio::DB::Tam");
#line 226 "lib/Bio/DB/Sam.xs"
      RETVAL = sam_header_read(tam);
#line 369 "lib/Bio/DB/Sam.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Bio::DB::Bam::Header", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__Tam_read1); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__Tam_read1)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "tam, header, alignment");
    {
	Bio__DB__Tam	tam;
	Bio__DB__Bam__Header	header;
	Bio__DB__Bam__Alignment	alignment;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::Tam")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    tam = INT2PTR(Bio__DB__Tam,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::Tam::read1",
			"tam", "Bio::DB::Tam");

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "Bio::DB::Bam::Header")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    header = INT2PTR(Bio__DB__Bam__Header,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::Tam::read1",
			"header", "Bio::DB::Bam::Header");

	if (SvROK(ST(2)) && sv_derived_from(ST(2), "Bio::DB::Bam::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(2)));
	    alignment = INT2PTR(Bio__DB__Bam__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::Tam::read1",
			"alignment", "Bio::DB::Bam::Alignment");
#line 236 "lib/Bio/DB/Sam.xs"
       RETVAL = sam_read1(tam,header,alignment);
#line 422 "lib/Bio/DB/Sam.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__Sam__Fai_load); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__Sam__Fai_load)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "packname=\"Bio::DB::Sam::Fai\", filename");
    {
	char *	packname;
	char *	filename = (char *)SvPV_nolen(ST(1));
	Bio__DB__Sam__Fai	RETVAL;

	if (items < 1)
	    packname = "Bio::DB::Sam::Fai";
	else {
	    packname = (char *)SvPV_nolen(ST(0));
	}
#line 248 "lib/Bio/DB/Sam.xs"
    RETVAL = fai_load(filename);
#line 451 "lib/Bio/DB/Sam.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Bio::DB::Sam::Fai", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__Sam__Fai_destroy); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__Sam__Fai_destroy)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "fai");
    {
	Bio__DB__Sam__Fai	fai;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::Sam::Fai")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    fai = INT2PTR(Bio__DB__Sam__Fai,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::Sam::Fai::destroy",
			"fai", "Bio::DB::Sam::Fai");
#line 257 "lib/Bio/DB/Sam.xs"
    fai_destroy(fai);
#line 482 "lib/Bio/DB/Sam.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Bio__DB__Sam__Fai_fetch); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__Sam__Fai_fetch)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "fai, reg");
    {
	Bio__DB__Sam__Fai	fai;
	const char *	reg = (const char *)SvPV_nolen(ST(1));
#line 265 "lib/Bio/DB/Sam.xs"
    char     *seq;
    int       len;
#line 504 "lib/Bio/DB/Sam.c"
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::Sam::Fai")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    fai = INT2PTR(Bio__DB__Sam__Fai,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::Sam::Fai::fetch",
			"fai", "Bio::DB::Sam::Fai");
#line 268 "lib/Bio/DB/Sam.xs"
    seq = fai_fetch(fai,reg,&len);
    if (seq == NULL)
       XSRETURN_EMPTY;
    RETVAL = newSVpv(seq,len);
    free((void*)seq);
#line 521 "lib/Bio/DB/Sam.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__Bam_open); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__Bam_open)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "packname, filename, mode=\"r\"");
    {
	char *	packname = (char *)SvPV_nolen(ST(0));
	char *	filename = (char *)SvPV_nolen(ST(1));
	char *	mode;
	Bio__DB__Bam	RETVAL;

	if (items < 3)
	    mode = "r";
	else {
	    mode = (char *)SvPV_nolen(ST(2));
	}
#line 286 "lib/Bio/DB/Sam.xs"
        RETVAL = bam_open(filename,mode);
#line 552 "lib/Bio/DB/Sam.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Bio::DB::Bam", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__Bam_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__Bam_DESTROY)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "bam");
    {
	Bio__DB__Bam	bam;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    bam = INT2PTR(Bio__DB__Bam,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not a reference",
			"Bio::DB::Bam::DESTROY",
			"bam");
#line 295 "lib/Bio/DB/Sam.xs"
   bam_close(bam);
#line 583 "lib/Bio/DB/Sam.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Bio__DB__Bam_index_build); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__Bam_index_build)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "packname, filename");
    {
	char *	packname = (char *)SvPV_nolen(ST(0));
	const char *	filename = (const char *)SvPV_nolen(ST(1));
	int	RETVAL;
	dXSTARG;
#line 302 "lib/Bio/DB/Sam.xs"
     RETVAL = bam_index_build(filename);
#line 606 "lib/Bio/DB/Sam.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__Bam_sort_core); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__Bam_sort_core)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 3 || items > 5)
       croak_xs_usage(cv,  "packname, is_by_qname=0, filename, prefix, max_mem=500000000");
    {
	char *	packname = (char *)SvPV_nolen(ST(0));
	int	is_by_qname;
	char *	filename = (char *)SvPV_nolen(ST(2));
	char *	prefix = (char *)SvPV_nolen(ST(3));
	int	max_mem;

	if (items < 2)
	    is_by_qname = 0;
	else {
	    is_by_qname = (int)SvIV(ST(1));
	}

	if (items < 5)
	    max_mem = 500000000;
	else {
	    max_mem = (int)SvIV(ST(4));
	}
#line 315 "lib/Bio/DB/Sam.xs"
   bam_sort_core(is_by_qname,filename,prefix,max_mem);
#line 643 "lib/Bio/DB/Sam.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Bio__DB__Bam_index_open); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__Bam_index_open)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "packname=\"Bio::DB::Bam\", filename");
    {
	char *	packname;
	char *	filename = (char *)SvPV_nolen(ST(1));
	Bio__DB__Bam__Index	RETVAL;

	if (items < 1)
	    packname = "Bio::DB::Bam";
	else {
	    packname = (char *)SvPV_nolen(ST(0));
	}
#line 323 "lib/Bio/DB/Sam.xs"
    RETVAL = bam_index_load(filename);
#line 671 "lib/Bio/DB/Sam.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Bio::DB::Bam::Index", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__Bam_header); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__Bam_header)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "bam");
    {
	Bio__DB__Bam	bam;
#line 332 "lib/Bio/DB/Sam.xs"
      bam_header_t *bh;
      int64_t       result;
#line 694 "lib/Bio/DB/Sam.c"
	Bio__DB__Bam__Header	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::Bam")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    bam = INT2PTR(Bio__DB__Bam,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::Bam::header",
			"bam", "Bio::DB::Bam");
#line 335 "lib/Bio/DB/Sam.xs"
      result = bgzf_seek(bam,0,0);
      bh = bam_header_read(bam);
      RETVAL = bh;
#line 709 "lib/Bio/DB/Sam.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Bio::DB::Bam::Header", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__Bam_header_write); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__Bam_header_write)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "bam, header");
    {
	Bio__DB__Bam	bam;
	Bio__DB__Bam__Header	header;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::Bam")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    bam = INT2PTR(Bio__DB__Bam,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::Bam::header_write",
			"bam", "Bio::DB::Bam");

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "Bio::DB::Bam::Header")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    header = INT2PTR(Bio__DB__Bam__Header,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::Bam::header_write",
			"header", "Bio::DB::Bam::Header");
#line 347 "lib/Bio/DB/Sam.xs"
      bgzf_seek(bam,0,0);
      RETVAL= bam_header_write(bam,header);
#line 753 "lib/Bio/DB/Sam.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__Bam_tell); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__Bam_tell)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "bam");
    {
	Bio__DB__Bam	bam;
	char *	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::Bam")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    bam = INT2PTR(Bio__DB__Bam,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::Bam::tell",
			"bam", "Bio::DB::Bam");
#line 357 "lib/Bio/DB/Sam.xs"
    int64_t t = bam_tell(bam);
    char    string[128];
    sprintf(string,"%llu",t);
    RETVAL = string;
#line 788 "lib/Bio/DB/Sam.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__Bam_seek); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__Bam_seek)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "bam, pos, dir");
    {
	Bio__DB__Bam	bam;
	int	pos = (int)SvIV(ST(1));
	int	dir = (int)SvIV(ST(2));

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::Bam")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    bam = INT2PTR(Bio__DB__Bam,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::Bam::seek",
			"bam", "Bio::DB::Bam");
#line 371 "lib/Bio/DB/Sam.xs"
    bam_seek(bam,pos,dir);
#line 820 "lib/Bio/DB/Sam.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Bio__DB__Bam_read1); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__Bam_read1)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "bam");
    {
	Bio__DB__Bam	bam;
#line 378 "lib/Bio/DB/Sam.xs"
    bam1_t *b;
#line 840 "lib/Bio/DB/Sam.c"
	Bio__DB__Bam__Alignment	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::Bam")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    bam = INT2PTR(Bio__DB__Bam,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::Bam::read1",
			"bam", "Bio::DB::Bam");
#line 380 "lib/Bio/DB/Sam.xs"
    b = bam_init1();
    if (bam_read1(bam,b) >= 0) {
      RETVAL = b;
    }
    else
       XSRETURN_EMPTY;
#line 858 "lib/Bio/DB/Sam.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Bio::DB::Bam::Alignment", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__Bam_write1); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__Bam_write1)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "bam, align");
    {
	Bio__DB__Bam	bam;
	Bio__DB__Bam__Alignment	align;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::Bam")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    bam = INT2PTR(Bio__DB__Bam,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::Bam::write1",
			"bam", "Bio::DB::Bam");

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "Bio::DB::Bam::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    align = INT2PTR(Bio__DB__Bam__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::Bam::write1",
			"align", "Bio::DB::Bam::Alignment");
#line 395 "lib/Bio/DB/Sam.xs"
      RETVAL = bam_write1(bam,align);
#line 901 "lib/Bio/DB/Sam.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__Bam__Alignment_new); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__Bam__Alignment_new)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 0 || items > 1)
       croak_xs_usage(cv,  "package=\"Bio::DB::Bam::Alignment\"");
    {
	char *	package;
	Bio__DB__Bam__Alignment	RETVAL;

	if (items < 1)
	    package = "Bio::DB::Bam::Alignment";
	else {
	    package = (char *)SvPV_nolen(ST(0));
	}
#line 406 "lib/Bio/DB/Sam.xs"
      RETVAL = bam_init1();
#line 929 "lib/Bio/DB/Sam.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Bio::DB::Bam::Alignment", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__Bam__Alignment_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__Bam__Alignment_DESTROY)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "b");
    {
	Bio__DB__Bam__Alignment	b;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__Bam__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not a reference",
			"Bio::DB::Bam::Alignment::DESTROY",
			"b");
#line 415 "lib/Bio/DB/Sam.xs"
    bam_destroy1(b);
#line 960 "lib/Bio/DB/Sam.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Bio__DB__Bam__Alignment_tid); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__Bam__Alignment_tid)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1)
       croak_xs_usage(cv,  "b, ...");
    {
	Bio__DB__Bam__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::Bam::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__Bam__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::Bam::Alignment::tid",
			"b", "Bio::DB::Bam::Alignment");
#line 422 "lib/Bio/DB/Sam.xs"
    if (items > 1)
      b->core.tid = SvIV(ST(1));
    RETVAL=b->core.tid;
#line 993 "lib/Bio/DB/Sam.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__Bam__Alignment_pos); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__Bam__Alignment_pos)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1)
       croak_xs_usage(cv,  "b, ...");
    {
	Bio__DB__Bam__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::Bam::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__Bam__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::Bam::Alignment::pos",
			"b", "Bio::DB::Bam::Alignment");
#line 433 "lib/Bio/DB/Sam.xs"
    if (items > 1)
      b->core.pos = SvIV(ST(1));
    RETVAL=b->core.pos;
#line 1027 "lib/Bio/DB/Sam.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__Bam__Alignment_calend); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__Bam__Alignment_calend)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "b");
    {
	Bio__DB__Bam__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::Bam::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__Bam__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::Bam::Alignment::calend",
			"b", "Bio::DB::Bam::Alignment");
#line 444 "lib/Bio/DB/Sam.xs"
   RETVAL=bam_calend(&b->core,bam1_cigar(b));
#line 1059 "lib/Bio/DB/Sam.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__Bam__Alignment_cigar2qlen); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__Bam__Alignment_cigar2qlen)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "b");
    {
	Bio__DB__Bam__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::Bam::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__Bam__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::Bam::Alignment::cigar2qlen",
			"b", "Bio::DB::Bam::Alignment");
#line 453 "lib/Bio/DB/Sam.xs"
   RETVAL=bam_cigar2qlen(&b->core,bam1_cigar(b));
#line 1091 "lib/Bio/DB/Sam.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__Bam__Alignment_qual); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__Bam__Alignment_qual)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1)
       croak_xs_usage(cv,  "b, ...");
    {
	Bio__DB__Bam__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::Bam::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__Bam__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::Bam::Alignment::qual",
			"b", "Bio::DB::Bam::Alignment");
#line 462 "lib/Bio/DB/Sam.xs"
    if (items > 1)
      b->core.qual = SvIV(ST(1));
    RETVAL=b->core.qual;
#line 1125 "lib/Bio/DB/Sam.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__Bam__Alignment_flag); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__Bam__Alignment_flag)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1)
       croak_xs_usage(cv,  "b, ...");
    {
	Bio__DB__Bam__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::Bam::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__Bam__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::Bam::Alignment::flag",
			"b", "Bio::DB::Bam::Alignment");
#line 473 "lib/Bio/DB/Sam.xs"
    if (items > 1)
      b->core.flag = SvIV(ST(1));
    RETVAL=b->core.flag;
#line 1159 "lib/Bio/DB/Sam.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__Bam__Alignment_n_cigar); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__Bam__Alignment_n_cigar)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1)
       croak_xs_usage(cv,  "b, ...");
    {
	Bio__DB__Bam__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::Bam::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__Bam__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::Bam::Alignment::n_cigar",
			"b", "Bio::DB::Bam::Alignment");
#line 484 "lib/Bio/DB/Sam.xs"
  if (items > 1)
    b->core.n_cigar = SvIV(ST(1));
    RETVAL=b->core.n_cigar;
#line 1193 "lib/Bio/DB/Sam.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__Bam__Alignment_l_qseq); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__Bam__Alignment_l_qseq)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1)
       croak_xs_usage(cv,  "b, ...");
    {
	Bio__DB__Bam__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::Bam::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__Bam__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::Bam::Alignment::l_qseq",
			"b", "Bio::DB::Bam::Alignment");
#line 495 "lib/Bio/DB/Sam.xs"
    if (items > 1)
      b->core.l_qseq = SvIV(ST(1));
    RETVAL=b->core.l_qseq;
#line 1227 "lib/Bio/DB/Sam.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__Bam__Alignment_qseq); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__Bam__Alignment_qseq)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "b");
    {
	Bio__DB__Bam__Alignment	b;
#line 506 "lib/Bio/DB/Sam.xs"
    char* seq;
    int   i;
#line 1249 "lib/Bio/DB/Sam.c"
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::Bam::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__Bam__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::Bam::Alignment::qseq",
			"b", "Bio::DB::Bam::Alignment");
#line 509 "lib/Bio/DB/Sam.xs"
    seq = Newxz(seq,b->core.l_qseq+1,char);
    for (i=0;i<b->core.l_qseq;i++) {
      seq[i]=bam_nt16_rev_table[bam1_seqi(bam1_seq(b),i)];
    }
    RETVAL = newSVpv(seq,b->core.l_qseq);
    Safefree(seq);
#line 1267 "lib/Bio/DB/Sam.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__Bam__Alignment__qscore); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__Bam__Alignment__qscore)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "b");
    {
	Bio__DB__Bam__Alignment	b;
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::Bam::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__Bam__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::Bam::Alignment::_qscore",
			"b", "Bio::DB::Bam::Alignment");
#line 523 "lib/Bio/DB/Sam.xs"
    RETVAL = newSVpv(bam1_qual(b),b->core.l_qseq);
#line 1299 "lib/Bio/DB/Sam.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__Bam__Alignment_mtid); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__Bam__Alignment_mtid)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1)
       croak_xs_usage(cv,  "b, ...");
    {
	Bio__DB__Bam__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::Bam::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__Bam__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::Bam::Alignment::mtid",
			"b", "Bio::DB::Bam::Alignment");
#line 532 "lib/Bio/DB/Sam.xs"
    if (items > 1)
      b->core.mtid = SvIV(ST(1));
    RETVAL=b->core.mtid;
#line 1334 "lib/Bio/DB/Sam.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__Bam__Alignment_mpos); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__Bam__Alignment_mpos)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1)
       croak_xs_usage(cv,  "b, ...");
    {
	Bio__DB__Bam__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::Bam::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__Bam__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::Bam::Alignment::mpos",
			"b", "Bio::DB::Bam::Alignment");
#line 543 "lib/Bio/DB/Sam.xs"
    if (items > 1)
      b->core.mpos = SvIV(ST(1));
    if (b->core.pos <= 0)
      XSRETURN_UNDEF;
    RETVAL=b->core.mpos;
#line 1370 "lib/Bio/DB/Sam.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__Bam__Alignment_isize); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__Bam__Alignment_isize)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1)
       croak_xs_usage(cv,  "b, ...");
    {
	Bio__DB__Bam__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::Bam::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__Bam__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::Bam::Alignment::isize",
			"b", "Bio::DB::Bam::Alignment");
#line 556 "lib/Bio/DB/Sam.xs"
    if (items > 1)
      b->core.isize = SvIV(ST(1));
    RETVAL=b->core.isize;
#line 1404 "lib/Bio/DB/Sam.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__Bam__Alignment_l_aux); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__Bam__Alignment_l_aux)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1)
       croak_xs_usage(cv,  "b, ...");
    {
	Bio__DB__Bam__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::Bam::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__Bam__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::Bam::Alignment::l_aux",
			"b", "Bio::DB::Bam::Alignment");
#line 567 "lib/Bio/DB/Sam.xs"
    if (items > 1)
      b->l_aux = SvIV(ST(1));
    RETVAL=b->l_aux;
#line 1438 "lib/Bio/DB/Sam.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__Bam__Alignment_aux); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__Bam__Alignment_aux)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "b");
    {
	Bio__DB__Bam__Alignment	b;
#line 577 "lib/Bio/DB/Sam.xs"
   uint8_t *s;
   uint8_t type, key[2];
   char    str[8192];
#line 1461 "lib/Bio/DB/Sam.c"
	char *	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::Bam::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__Bam__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::Bam::Alignment::aux",
			"b", "Bio::DB::Bam::Alignment");
#line 581 "lib/Bio/DB/Sam.xs"
   s = bam1_aux(b);
   str[0] = '\0';

   int left  = sizeof(str) - strlen(str);
   while (left > 0 && (s < b->data + b->data_len)) {
        char* d   = str+strlen(str); 

	key[0] = s[0]; 
	key[1] = s[1];
 	left -= snprintf(d, left, "%c%c:", key[0], key[1]);

	d    += 3;
	s    += 2;
	type = *s++; 

	if (left <= 0) continue;

	if (type == 'A')      { left -= snprintf(d, left, "A:%c", *s);           s++; }
	else if (type == 'C') { left -= snprintf(d, left, "i:%u", *s);           s++; }
	else if (type == 'c') { left -= snprintf(d, left, "i:%d", *s);           s++; }
	else if (type == 'S') { left -= snprintf(d, left, "i:%u", *(uint16_t*)s);s += 2; }
	else if (type == 's') { left -= snprintf(d, left, "i:%d", *(int16_t*)s); s += 2; }
	else if (type == 'I') { left -= snprintf(d, left, "i:%u", *(uint32_t*)s);s += 4; }
	else if (type == 'i') { left -= snprintf(d, left, "i:%d", *(int32_t*)s); s += 4; }
	else if (type == 'f') { left -= snprintf(d, left, "f:%g", *(float*)s);   s += 4; }
	else if (type == 'd') { left -= snprintf(d, left, "d:%lg", *(double*)s); s += 8; }
	else if (type == 'Z' || type == 'H') { left -= snprintf(d, left, "%c:", type); 
	                                       strncat(d,s,left);
					       while (*s++) {}
					       left = sizeof(str) - strlen(str);
	                                     }
	if (left <= 0) continue;
	strncat(d,"\t",left);
	left--;
   }	  
   str[strlen(str)-1] = '\0';
   RETVAL = str;
#line 1511 "lib/Bio/DB/Sam.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__Bam__Alignment_aux_get); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__Bam__Alignment_aux_get)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "b, tag");
    {
	Bio__DB__Bam__Alignment	b;
	char*	tag = (char *)SvPV_nolen(ST(1));
#line 627 "lib/Bio/DB/Sam.xs"
   int           type;
   uint8_t       *s;
#line 1534 "lib/Bio/DB/Sam.c"
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::Bam::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__Bam__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::Bam::Alignment::aux_get",
			"b", "Bio::DB::Bam::Alignment");
#line 630 "lib/Bio/DB/Sam.xs"
   s    = bam_aux_get_core(b,tag);
   if (s==0)
      XSRETURN_EMPTY;
   type = *s++;
   switch (type) {
   case 'c':
     RETVAL = newSViv((int32_t)*(int8_t*)s);
     break;
   case 'C':
     RETVAL = newSViv((int32_t)*(uint8_t*)s);
     break;
   case 's':
     RETVAL = newSViv((int32_t)*(int16_t*)s);
     break;
   case 'S':
     RETVAL = newSViv((int32_t)*(uint16_t*)s);
     break;
   case 'i':
     RETVAL = newSViv(*(int32_t*)s);
     break;
   case 'I':
     RETVAL = newSViv((int32_t)*(uint32_t*)s);
     break;
   case 'f':
     RETVAL = newSVnv(*(float*)s);
     break;
   case 'Z':
   case 'H':
     RETVAL = newSVpv((char*)s,0);
     break;
   case 'A':
     RETVAL = newSVpv((char*)s,1);
     break;
   default:
     XSRETURN_EMPTY;
   }
#line 1582 "lib/Bio/DB/Sam.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__Bam__Alignment_aux_keys); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__Bam__Alignment_aux_keys)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "b");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	Bio__DB__Bam__Alignment	b;
#line 674 "lib/Bio/DB/Sam.xs"
   uint8_t *s;
   uint8_t type;
#line 1607 "lib/Bio/DB/Sam.c"

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::Bam::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__Bam__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::Bam::Alignment::aux_keys",
			"b", "Bio::DB::Bam::Alignment");
#line 677 "lib/Bio/DB/Sam.xs"
   {
     s = bam1_aux(b);  /* s is a khash macro */
     while (s < b->data + b->data_len) {
       XPUSHs(sv_2mortal(newSVpv(s,2)));
       s   += 2; 
       type = *s++;
       if      (type == 'A') { ++s; }
       else if (type == 'C') { ++s; }
       else if (type == 'c') { ++s; }
       else if (type == 'S') { s += 2; }
       else if (type == 's') { s += 2; }
       else if (type == 'I') { s += 4; }
       else if (type == 'i') { s += 4; }
       else if (type == 'f') { s += 4; }
       else if (type == 'Z' || type == 'H') { while (*s) ++(s); ++(s); }
     }
   }
#line 1635 "lib/Bio/DB/Sam.c"
	PUTBACK;
	return;
    }
}


XS(XS_Bio__DB__Bam__Alignment_data); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__Bam__Alignment_data)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1)
       croak_xs_usage(cv,  "b, ...");
    {
	Bio__DB__Bam__Alignment	b;
#line 700 "lib/Bio/DB/Sam.xs"
    STRLEN  len;
#line 1656 "lib/Bio/DB/Sam.c"
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::Bam::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__Bam__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::Bam::Alignment::data",
			"b", "Bio::DB::Bam::Alignment");
#line 702 "lib/Bio/DB/Sam.xs"
    if (items > 1) {
      b->data     = SvPV(ST(1),len);
      b->data_len = len;
    }
    RETVAL=newSVpv(b->data,b->data_len);
#line 1673 "lib/Bio/DB/Sam.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__Bam__Alignment_data_len); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__Bam__Alignment_data_len)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1)
       croak_xs_usage(cv,  "b, ...");
    {
	Bio__DB__Bam__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::Bam::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__Bam__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::Bam::Alignment::data_len",
			"b", "Bio::DB::Bam::Alignment");
#line 715 "lib/Bio/DB/Sam.xs"
    if (items > 1)
      b->data_len = SvIV(ST(1));
    RETVAL=b->data_len;
#line 1708 "lib/Bio/DB/Sam.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__Bam__Alignment_m_data); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__Bam__Alignment_m_data)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1)
       croak_xs_usage(cv,  "b, ...");
    {
	Bio__DB__Bam__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::Bam::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__Bam__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::Bam::Alignment::m_data",
			"b", "Bio::DB::Bam::Alignment");
#line 726 "lib/Bio/DB/Sam.xs"
    if (items > 1) {
      b->m_data = SvIV(ST(1));
    }
    RETVAL=b->m_data;
#line 1743 "lib/Bio/DB/Sam.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__Bam__Alignment_qname); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__Bam__Alignment_qname)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "b");
    {
	Bio__DB__Bam__Alignment	b;
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::Bam::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__Bam__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::Bam::Alignment::qname",
			"b", "Bio::DB::Bam::Alignment");
#line 738 "lib/Bio/DB/Sam.xs"
    RETVAL=newSVpv(bam1_qname(b),0);
#line 1774 "lib/Bio/DB/Sam.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__Bam__Alignment_paired); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__Bam__Alignment_paired)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "b");
    {
	Bio__DB__Bam__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::Bam::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__Bam__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::Bam::Alignment::paired",
			"b", "Bio::DB::Bam::Alignment");
#line 747 "lib/Bio/DB/Sam.xs"
    RETVAL=(b->core.flag&BAM_FPAIRED) != 0;
#line 1807 "lib/Bio/DB/Sam.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__Bam__Alignment_proper_pair); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__Bam__Alignment_proper_pair)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "b");
    {
	Bio__DB__Bam__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::Bam::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__Bam__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::Bam::Alignment::proper_pair",
			"b", "Bio::DB::Bam::Alignment");
#line 756 "lib/Bio/DB/Sam.xs"
    RETVAL=(b->core.flag&BAM_FPROPER_PAIR) != 0;
#line 1839 "lib/Bio/DB/Sam.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__Bam__Alignment_unmapped); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__Bam__Alignment_unmapped)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "b");
    {
	Bio__DB__Bam__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::Bam::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__Bam__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::Bam::Alignment::unmapped",
			"b", "Bio::DB::Bam::Alignment");
#line 765 "lib/Bio/DB/Sam.xs"
    RETVAL=(b->core.flag&BAM_FUNMAP) != 0;
#line 1871 "lib/Bio/DB/Sam.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__Bam__Alignment_munmapped); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__Bam__Alignment_munmapped)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "b");
    {
	Bio__DB__Bam__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::Bam::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__Bam__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::Bam::Alignment::munmapped",
			"b", "Bio::DB::Bam::Alignment");
#line 774 "lib/Bio/DB/Sam.xs"
    RETVAL=(b->core.flag&BAM_FMUNMAP) != 0;
#line 1903 "lib/Bio/DB/Sam.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__Bam__Alignment_reversed); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__Bam__Alignment_reversed)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "b");
    {
	Bio__DB__Bam__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::Bam::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__Bam__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::Bam::Alignment::reversed",
			"b", "Bio::DB::Bam::Alignment");
#line 783 "lib/Bio/DB/Sam.xs"
  RETVAL=bam1_strand(b);
#line 1935 "lib/Bio/DB/Sam.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__Bam__Alignment_mreversed); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__Bam__Alignment_mreversed)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "b");
    {
	Bio__DB__Bam__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::Bam::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__Bam__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::Bam::Alignment::mreversed",
			"b", "Bio::DB::Bam::Alignment");
#line 792 "lib/Bio/DB/Sam.xs"
  RETVAL=bam1_mstrand(b);
#line 1967 "lib/Bio/DB/Sam.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__Bam__Alignment_cigar); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__Bam__Alignment_cigar)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "b");
    {
	Bio__DB__Bam__Alignment	b;
#line 801 "lib/Bio/DB/Sam.xs"
    int        i;
    uint32_t  *c;
    AV        *avref;
#line 1990 "lib/Bio/DB/Sam.c"
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::Bam::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__Bam__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::Bam::Alignment::cigar",
			"b", "Bio::DB::Bam::Alignment");
#line 805 "lib/Bio/DB/Sam.xs"
    avref = (AV*) sv_2mortal((SV*)newAV());
    c     = bam1_cigar(b);
    for (i=0;i<b->core.n_cigar;i++)
      av_push(avref, newSViv(c[i]));
    RETVAL = (SV*) newRV((SV*)avref); 
#line 2007 "lib/Bio/DB/Sam.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__Bam__Header_new); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__Bam__Header_new)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 0 || items > 1)
       croak_xs_usage(cv,  "packname=Bio::DB::Bam::Header");
    {
	Bio__DB__Bam__Header	RETVAL;
#line 819 "lib/Bio/DB/Sam.xs"
    RETVAL = bam_header_init();
#line 2029 "lib/Bio/DB/Sam.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Bio::DB::Bam::Header", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__Bam__Header_n_targets); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__Bam__Header_n_targets)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "bamh");
    {
	Bio__DB__Bam__Header	bamh;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::Bam::Header")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    bamh = INT2PTR(Bio__DB__Bam__Header,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::Bam::Header::n_targets",
			"bamh", "Bio::DB::Bam::Header");
#line 828 "lib/Bio/DB/Sam.xs"
    RETVAL = bamh->n_targets;
#line 2062 "lib/Bio/DB/Sam.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__Bam__Header_target_name); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__Bam__Header_target_name)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "bamh");
    {
	Bio__DB__Bam__Header	bamh;
#line 837 "lib/Bio/DB/Sam.xs"
    int i;
    AV * avref;
#line 2084 "lib/Bio/DB/Sam.c"
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::Bam::Header")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    bamh = INT2PTR(Bio__DB__Bam__Header,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::Bam::Header::target_name",
			"bamh", "Bio::DB::Bam::Header");
#line 840 "lib/Bio/DB/Sam.xs"
    avref = (AV*) sv_2mortal((SV*)newAV());
    for (i=0;i<bamh->n_targets;i++)
      av_push(avref, newSVpv(bamh->target_name[i],0));
    RETVAL = (SV*) newRV((SV*)avref); 
#line 2100 "lib/Bio/DB/Sam.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__Bam__Header_target_len); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__Bam__Header_target_len)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "bamh");
    {
	Bio__DB__Bam__Header	bamh;
#line 852 "lib/Bio/DB/Sam.xs"
    int i;
    AV * avref;
#line 2123 "lib/Bio/DB/Sam.c"
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::Bam::Header")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    bamh = INT2PTR(Bio__DB__Bam__Header,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::Bam::Header::target_len",
			"bamh", "Bio::DB::Bam::Header");
#line 855 "lib/Bio/DB/Sam.xs"
    avref = (AV*) sv_2mortal((SV*)newAV());
    for (i=0;i<bamh->n_targets;i++)
       av_push(avref, newSViv(bamh->target_len[i]));
    RETVAL = (SV*) newRV((SV*)avref); 
#line 2139 "lib/Bio/DB/Sam.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__Bam__Header_text); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__Bam__Header_text)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 1)
       croak_xs_usage(cv,  "bamh, ...");
    {
	Bio__DB__Bam__Header	bamh;
#line 866 "lib/Bio/DB/Sam.xs"
    char   *newtext;
    STRLEN n;
#line 2162 "lib/Bio/DB/Sam.c"
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::Bam::Header")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    bamh = INT2PTR(Bio__DB__Bam__Header,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::Bam::Header::text",
			"bamh", "Bio::DB::Bam::Header");
#line 869 "lib/Bio/DB/Sam.xs"
    /* in case text is not null terminated, we copy it */
    RETVAL = newSVpv(bamh->text,bamh->l_text);
    if (items > 1) {
      newtext = (char*) SvPV(ST(1),n);
      bamh->text   = newtext;
      bamh->l_text = n;
    }
#line 2181 "lib/Bio/DB/Sam.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__Bam__Header_parse_region); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__Bam__Header_parse_region)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "bamh, region");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	Bio__DB__Bam__Header	bamh;
	char*	region = (char *)SvPV_nolen(ST(1));
#line 885 "lib/Bio/DB/Sam.xs"
       int seqid,start,end;
#line 2206 "lib/Bio/DB/Sam.c"

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::Bam::Header")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    bamh = INT2PTR(Bio__DB__Bam__Header,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::Bam::Header::parse_region",
			"bamh", "Bio::DB::Bam::Header");
#line 887 "lib/Bio/DB/Sam.xs"
    {
      bam_parse_region(bamh,
		       region,
		       &seqid,
		       &start,
		       &end);
      if (seqid < 0)
	XSRETURN_EMPTY;
      else {
	EXTEND(sp,3);
	PUSHs(sv_2mortal(newSViv(seqid)));
	PUSHs(sv_2mortal(newSViv(start)));
	PUSHs(sv_2mortal(newSViv(end)));
      }
    }
#line 2232 "lib/Bio/DB/Sam.c"
	PUTBACK;
	return;
    }
}


XS(XS_Bio__DB__Bam__Header_view1); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__Bam__Header_view1)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 2)
       croak_xs_usage(cv,  "bamh, alignment");
    {
	Bio__DB__Bam__Header	bamh;
	Bio__DB__Bam__Alignment	alignment;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::Bam::Header")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    bamh = INT2PTR(Bio__DB__Bam__Header,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::Bam::Header::view1",
			"bamh", "Bio::DB::Bam::Header");

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "Bio::DB::Bam::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    alignment = INT2PTR(Bio__DB__Bam__Alignment,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::Bam::Header::view1",
			"alignment", "Bio::DB::Bam::Alignment");
#line 909 "lib/Bio/DB/Sam.xs"
       bam_view1(bamh,alignment);
#line 2272 "lib/Bio/DB/Sam.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Bio__DB__Bam__Header_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__Bam__Header_DESTROY)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "bamh");
    {
	Bio__DB__Bam__Header	bamh;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    bamh = INT2PTR(Bio__DB__Bam__Header,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not a reference",
			"Bio::DB::Bam::Header::DESTROY",
			"bamh");
#line 916 "lib/Bio/DB/Sam.xs"
    bam_header_destroy(bamh);
#line 2301 "lib/Bio/DB/Sam.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Bio__DB__Bam__Index_fetch); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__Bam__Index_fetch)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 6 || items > 7)
       croak_xs_usage(cv,  "bai, bfp, ref, start, end, callback, callbackdata=&PL_sv_undef");
    {
	Bio__DB__Bam__Index	bai;
	Bio__DB__Bam	bfp;
	int	ref = (int)SvIV(ST(2));
	int	start = (int)SvIV(ST(3));
	int	end = (int)SvIV(ST(4));
	CV*	callback;
	SV*	callbackdata;
#line 930 "lib/Bio/DB/Sam.xs"
  fetch_callback_data fcd;
#line 2327 "lib/Bio/DB/Sam.c"
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::Bam::Index")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    bai = INT2PTR(Bio__DB__Bam__Index,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::Bam::Index::fetch",
			"bai", "Bio::DB::Bam::Index");

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "Bio::DB::Bam")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    bfp = INT2PTR(Bio__DB__Bam,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::Bam::Index::fetch",
			"bfp", "Bio::DB::Bam");

	if (SvROK(ST(5)) && SvTYPE(SvRV(ST(5)))==SVt_PVCV)
	    callback = (CV*)SvRV(ST(5));
	else
	    Perl_croak(aTHX_ "%s: %s is not a code reference",
			"Bio::DB::Bam::Index::fetch",
			"callback");

	if (items < 7)
	    callbackdata = &PL_sv_undef;
	else {
	    callbackdata = ST(6);
	}
#line 932 "lib/Bio/DB/Sam.xs"
  {
    fcd.callback = (SV*) callback;
    fcd.data     = callbackdata;
    RETVAL = bam_fetch(bfp,bai,ref,start,end,&fcd,bam_fetch_fun);
  }
#line 2367 "lib/Bio/DB/Sam.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__Bam__Index_lpileup); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__Bam__Index_lpileup)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 6 || items > 7)
       croak_xs_usage(cv,  "bai, bfp, ref, start, end, callback, callbackdata=&PL_sv_undef");
    {
	Bio__DB__Bam__Index	bai;
	Bio__DB__Bam	bfp;
	int	ref = (int)SvIV(ST(2));
	int	start = (int)SvIV(ST(3));
	int	end = (int)SvIV(ST(4));
	CV*	callback;
	SV*	callbackdata;
#line 950 "lib/Bio/DB/Sam.xs"
  fetch_callback_data fcd;
  bam_lplbuf_t        *pileup;
#line 2395 "lib/Bio/DB/Sam.c"

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::Bam::Index")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    bai = INT2PTR(Bio__DB__Bam__Index,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::Bam::Index::lpileup",
			"bai", "Bio::DB::Bam::Index");

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "Bio::DB::Bam")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    bfp = INT2PTR(Bio__DB__Bam,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::Bam::Index::lpileup",
			"bfp", "Bio::DB::Bam");

	if (SvROK(ST(5)) && SvTYPE(SvRV(ST(5)))==SVt_PVCV)
	    callback = (CV*)SvRV(ST(5));
	else
	    Perl_croak(aTHX_ "%s: %s is not a code reference",
			"Bio::DB::Bam::Index::lpileup",
			"callback");

	if (items < 7)
	    callbackdata = &PL_sv_undef;
	else {
	    callbackdata = ST(6);
	}
#line 953 "lib/Bio/DB/Sam.xs"
  fcd.callback = (SV*) callback;
  fcd.data     = callbackdata;
  pileup       = bam_lplbuf_init(invoke_pileup_callback_fun,(void*)&fcd);
  bam_fetch(bfp,bai,ref,start,end,(void*)pileup,add_lpileup_line);
  bam_lplbuf_push(NULL,pileup);
  bam_lplbuf_destroy(pileup);
#line 2434 "lib/Bio/DB/Sam.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Bio__DB__Bam__Index_pileup); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__Bam__Index_pileup)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 6 || items > 7)
       croak_xs_usage(cv,  "bai, bfp, ref, start, end, callback, callbackdata=&PL_sv_undef");
    {
	Bio__DB__Bam__Index	bai;
	Bio__DB__Bam	bfp;
	int	ref = (int)SvIV(ST(2));
	int	start = (int)SvIV(ST(3));
	int	end = (int)SvIV(ST(4));
	CV*	callback;
	SV*	callbackdata;
#line 970 "lib/Bio/DB/Sam.xs"
  fetch_callback_data fcd;
  bam_plbuf_t        *pileup;
#line 2461 "lib/Bio/DB/Sam.c"

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::Bam::Index")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    bai = INT2PTR(Bio__DB__Bam__Index,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::Bam::Index::pileup",
			"bai", "Bio::DB::Bam::Index");

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "Bio::DB::Bam")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    bfp = INT2PTR(Bio__DB__Bam,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::Bam::Index::pileup",
			"bfp", "Bio::DB::Bam");

	if (SvROK(ST(5)) && SvTYPE(SvRV(ST(5)))==SVt_PVCV)
	    callback = (CV*)SvRV(ST(5));
	else
	    Perl_croak(aTHX_ "%s: %s is not a code reference",
			"Bio::DB::Bam::Index::pileup",
			"callback");

	if (items < 7)
	    callbackdata = &PL_sv_undef;
	else {
	    callbackdata = ST(6);
	}
#line 973 "lib/Bio/DB/Sam.xs"
  fcd.callback = (SV*) callback;
  fcd.data     = callbackdata;
  pileup       = bam_plbuf_init(invoke_pileup_callback_fun,(void*)&fcd);
  bam_fetch(bfp,bai,ref,start,end,(void*)pileup,add_pileup_line);
  bam_plbuf_push(NULL,pileup);
  bam_plbuf_destroy(pileup);
#line 2500 "lib/Bio/DB/Sam.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Bio__DB__Bam__Index_coverage); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__Bam__Index_coverage)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items < 5 || items > 6)
       croak_xs_usage(cv,  "bai, bfp, ref, start, end, bins=0");
    {
	Bio__DB__Bam__Index	bai;
	Bio__DB__Bam	bfp;
	int	ref = (int)SvIV(ST(2));
	int	start = (int)SvIV(ST(3));
	int	end = (int)SvIV(ST(4));
	int	bins;
#line 989 "lib/Bio/DB/Sam.xs"
    coverage_graph  cg;
    bam_plbuf_t    *pileup;
    AV*             array;
    SV*             cov;
    int             i;
    bam_header_t   *bh;
#line 2530 "lib/Bio/DB/Sam.c"
	AV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::Bam::Index")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    bai = INT2PTR(Bio__DB__Bam__Index,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::Bam::Index::coverage",
			"bai", "Bio::DB::Bam::Index");

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "Bio::DB::Bam")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    bfp = INT2PTR(Bio__DB__Bam,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::Bam::Index::coverage",
			"bfp", "Bio::DB::Bam");

	if (items < 6)
	    bins = 0;
	else {
	    bins = (int)SvIV(ST(5));
	}
#line 996 "lib/Bio/DB/Sam.xs"
  {
      if (end >= MAX_REGION) {
          bgzf_seek(bfp,0,0);
          bh  = bam_header_read(bfp);
          end = bh->target_len[ref];
          bam_header_destroy(bh);
      }
      if ((bins==0) || (bins > (end-start)))
         bins = end-start;

      /* coverage graph used to communicate to our callback
	  the region we are sampling */
      cg.start = start;
      cg.end   = end;
      cg.reads = 0;
      cg.width = ((double)(end-start))/bins;
      Newxz(cg.bin,bins+1,int);

      /* accumulate coverage into the coverage graph */
      pileup   = bam_plbuf_init(coverage_from_pileup_fun,(void*)&cg);
      bam_fetch(bfp,bai,ref,start,end,(void*)pileup,add_pileup_line);
      bam_plbuf_push(NULL,pileup);
      bam_plbuf_destroy(pileup);

      /* now normalize to coverage/bp and convert into an array */
      array = newAV();
      av_extend(array,bins);
      if (cg.reads > 0) {
            for  (i=0;i<bins;i++)
	    	av_store(array,i,newSVnv(((float)cg.bin[i])/cg.width));
      }
      Safefree(cg.bin);
      RETVAL = array;
      sv_2mortal((SV*)RETVAL);  /* this fixes a documented bug in perl typemap */

  }
#line 2593 "lib/Bio/DB/Sam.c"
	ST(0) = newRV((SV*)RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__Bam__Index_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__Bam__Index_DESTROY)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "bai");
    {
	Bio__DB__Bam__Index	bai;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    bai = INT2PTR(Bio__DB__Bam__Index,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not a reference",
			"Bio::DB::Bam::Index::DESTROY",
			"bai");
#line 1039 "lib/Bio/DB/Sam.xs"
    bam_index_destroy(bai);
#line 2624 "lib/Bio/DB/Sam.c"
    }
    XSRETURN_EMPTY;
}


XS(XS_Bio__DB__Bam__Pileup_qpos); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__Bam__Pileup_qpos)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "pl");
    {
	Bio__DB__Bam__Pileup	pl;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::Bam::Pileup")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    pl = INT2PTR(Bio__DB__Bam__Pileup,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::Bam::Pileup::qpos",
			"pl", "Bio::DB::Bam::Pileup");
#line 1047 "lib/Bio/DB/Sam.xs"
    RETVAL = pl->qpos;
#line 2655 "lib/Bio/DB/Sam.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__Bam__Pileup_pos); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__Bam__Pileup_pos)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "pl");
    {
	Bio__DB__Bam__Pileup	pl;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::Bam::Pileup")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    pl = INT2PTR(Bio__DB__Bam__Pileup,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::Bam::Pileup::pos",
			"pl", "Bio::DB::Bam::Pileup");
#line 1055 "lib/Bio/DB/Sam.xs"
    RETVAL = pl->qpos+1;
#line 2687 "lib/Bio/DB/Sam.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__Bam__Pileup_indel); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__Bam__Pileup_indel)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "pl");
    {
	Bio__DB__Bam__Pileup	pl;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::Bam::Pileup")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    pl = INT2PTR(Bio__DB__Bam__Pileup,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::Bam::Pileup::indel",
			"pl", "Bio::DB::Bam::Pileup");
#line 1063 "lib/Bio/DB/Sam.xs"
    RETVAL = pl->indel;
#line 2719 "lib/Bio/DB/Sam.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__Bam__Pileup_level); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__Bam__Pileup_level)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "pl");
    {
	Bio__DB__Bam__Pileup	pl;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::Bam::Pileup")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    pl = INT2PTR(Bio__DB__Bam__Pileup,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::Bam::Pileup::level",
			"pl", "Bio::DB::Bam::Pileup");
#line 1071 "lib/Bio/DB/Sam.xs"
    RETVAL = pl->level;
#line 2751 "lib/Bio/DB/Sam.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__Bam__Pileup_is_del); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__Bam__Pileup_is_del)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "pl");
    {
	Bio__DB__Bam__Pileup	pl;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::Bam::Pileup")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    pl = INT2PTR(Bio__DB__Bam__Pileup,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::Bam::Pileup::is_del",
			"pl", "Bio::DB::Bam::Pileup");
#line 1079 "lib/Bio/DB/Sam.xs"
    RETVAL = pl->is_del;
#line 2783 "lib/Bio/DB/Sam.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__Bam__Pileup_is_refskip); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__Bam__Pileup_is_refskip)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "pl");
    {
	Bio__DB__Bam__Pileup	pl;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::Bam::Pileup")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    pl = INT2PTR(Bio__DB__Bam__Pileup,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::Bam::Pileup::is_refskip",
			"pl", "Bio::DB::Bam::Pileup");
#line 1087 "lib/Bio/DB/Sam.xs"
    RETVAL = pl->is_refskip;
#line 2815 "lib/Bio/DB/Sam.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__Bam__Pileup_is_head); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__Bam__Pileup_is_head)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "pl");
    {
	Bio__DB__Bam__Pileup	pl;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::Bam::Pileup")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    pl = INT2PTR(Bio__DB__Bam__Pileup,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::Bam::Pileup::is_head",
			"pl", "Bio::DB::Bam::Pileup");
#line 1095 "lib/Bio/DB/Sam.xs"
    RETVAL = pl->is_head;
#line 2847 "lib/Bio/DB/Sam.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__Bam__Pileup_is_tail); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__Bam__Pileup_is_tail)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "pl");
    {
	Bio__DB__Bam__Pileup	pl;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::Bam::Pileup")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    pl = INT2PTR(Bio__DB__Bam__Pileup,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::Bam::Pileup::is_tail",
			"pl", "Bio::DB::Bam::Pileup");
#line 1103 "lib/Bio/DB/Sam.xs"
    RETVAL = pl->is_tail;
#line 2879 "lib/Bio/DB/Sam.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__Bam__Pileup_b); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__Bam__Pileup_b)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "pl");
    {
	Bio__DB__Bam__Pileup	pl;
	Bio__DB__Bam__Alignment	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::Bam::Pileup")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    pl = INT2PTR(Bio__DB__Bam__Pileup,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::Bam::Pileup::b",
			"pl", "Bio::DB::Bam::Pileup");
#line 1111 "lib/Bio/DB/Sam.xs"
    RETVAL = bam_dup1(pl->b);
#line 2910 "lib/Bio/DB/Sam.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Bio::DB::Bam::Alignment", (void*)RETVAL);
    }
    XSRETURN(1);
}


XS(XS_Bio__DB__Bam__Pileup_alignment); /* prototype to pass -Wmissing-prototypes */
XS(XS_Bio__DB__Bam__Pileup_alignment)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "pl");
    {
	Bio__DB__Bam__Pileup	pl;
	Bio__DB__Bam__Alignment	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::Bam::Pileup")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    pl = INT2PTR(Bio__DB__Bam__Pileup,tmp);
	}
	else
	    Perl_croak(aTHX_ "%s: %s is not of type %s",
			"Bio::DB::Bam::Pileup::alignment",
			"pl", "Bio::DB::Bam::Pileup");
#line 1119 "lib/Bio/DB/Sam.xs"
    RETVAL = bam_dup1(pl->b);
#line 2942 "lib/Bio/DB/Sam.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Bio::DB::Bam::Alignment", (void*)RETVAL);
    }
    XSRETURN(1);
}

#ifdef __cplusplus
extern "C"
#endif
XS(boot_Bio__DB__Sam); /* prototype to pass -Wmissing-prototypes */
XS(boot_Bio__DB__Sam)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
#if (PERL_REVISION == 5 && PERL_VERSION < 9)
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
    XS_VERSION_BOOTCHECK ;

        (void)newXSproto_portable("Bio::DB::Tam::open", XS_Bio__DB__Tam_open, file, "$$");
        (void)newXSproto_portable("Bio::DB::Tam::DESTROY", XS_Bio__DB__Tam_DESTROY, file, "$");
        (void)newXSproto_portable("Bio::DB::Tam::header_read2", XS_Bio__DB__Tam_header_read2, file, "$$");
        (void)newXSproto_portable("Bio::DB::Tam::header_read", XS_Bio__DB__Tam_header_read, file, "$$");
        (void)newXS("Bio::DB::Tam::read1", XS_Bio__DB__Tam_read1, file);
        (void)newXSproto_portable("Bio::DB::Sam::Fai::load", XS_Bio__DB__Sam__Fai_load, file, "$$");
        (void)newXSproto_portable("Bio::DB::Sam::Fai::destroy", XS_Bio__DB__Sam__Fai_destroy, file, "$");
        (void)newXSproto_portable("Bio::DB::Sam::Fai::fetch", XS_Bio__DB__Sam__Fai_fetch, file, "$$$");
        (void)newXSproto_portable("Bio::DB::Bam::open", XS_Bio__DB__Bam_open, file, "$$$");
        (void)newXSproto_portable("Bio::DB::Bam::DESTROY", XS_Bio__DB__Bam_DESTROY, file, "$");
        (void)newXS("Bio::DB::Bam::index_build", XS_Bio__DB__Bam_index_build, file);
        (void)newXSproto_portable("Bio::DB::Bam::sort_core", XS_Bio__DB__Bam_sort_core, file, "$$$$$");
        (void)newXSproto_portable("Bio::DB::Bam::index_open", XS_Bio__DB__Bam_index_open, file, "$$");
        (void)newXSproto_portable("Bio::DB::Bam::header", XS_Bio__DB__Bam_header, file, "$");
        (void)newXSproto_portable("Bio::DB::Bam::header_write", XS_Bio__DB__Bam_header_write, file, "$$");
        (void)newXSproto_portable("Bio::DB::Bam::tell", XS_Bio__DB__Bam_tell, file, "$");
        (void)newXSproto_portable("Bio::DB::Bam::seek", XS_Bio__DB__Bam_seek, file, "$$$");
        (void)newXSproto_portable("Bio::DB::Bam::read1", XS_Bio__DB__Bam_read1, file, "$");
        (void)newXSproto_portable("Bio::DB::Bam::write1", XS_Bio__DB__Bam_write1, file, "$$");
        (void)newXSproto_portable("Bio::DB::Bam::Alignment::new", XS_Bio__DB__Bam__Alignment_new, file, "$");
        (void)newXSproto_portable("Bio::DB::Bam::Alignment::DESTROY", XS_Bio__DB__Bam__Alignment_DESTROY, file, "$");
        (void)newXSproto_portable("Bio::DB::Bam::Alignment::tid", XS_Bio__DB__Bam__Alignment_tid, file, "$;$");
        (void)newXSproto_portable("Bio::DB::Bam::Alignment::pos", XS_Bio__DB__Bam__Alignment_pos, file, "$;$");
        (void)newXSproto_portable("Bio::DB::Bam::Alignment::calend", XS_Bio__DB__Bam__Alignment_calend, file, "$");
        (void)newXSproto_portable("Bio::DB::Bam::Alignment::cigar2qlen", XS_Bio__DB__Bam__Alignment_cigar2qlen, file, "$");
        (void)newXSproto_portable("Bio::DB::Bam::Alignment::qual", XS_Bio__DB__Bam__Alignment_qual, file, "$;$");
        (void)newXSproto_portable("Bio::DB::Bam::Alignment::flag", XS_Bio__DB__Bam__Alignment_flag, file, "$;$");
        (void)newXSproto_portable("Bio::DB::Bam::Alignment::n_cigar", XS_Bio__DB__Bam__Alignment_n_cigar, file, "$;$");
        (void)newXSproto_portable("Bio::DB::Bam::Alignment::l_qseq", XS_Bio__DB__Bam__Alignment_l_qseq, file, "$;$");
        (void)newXSproto_portable("Bio::DB::Bam::Alignment::qseq", XS_Bio__DB__Bam__Alignment_qseq, file, "$");
        (void)newXSproto_portable("Bio::DB::Bam::Alignment::_qscore", XS_Bio__DB__Bam__Alignment__qscore, file, "$");
        (void)newXSproto_portable("Bio::DB::Bam::Alignment::mtid", XS_Bio__DB__Bam__Alignment_mtid, file, "$;$");
        (void)newXSproto_portable("Bio::DB::Bam::Alignment::mpos", XS_Bio__DB__Bam__Alignment_mpos, file, "$;$");
        (void)newXSproto_portable("Bio::DB::Bam::Alignment::isize", XS_Bio__DB__Bam__Alignment_isize, file, "$;$");
        (void)newXSproto_portable("Bio::DB::Bam::Alignment::l_aux", XS_Bio__DB__Bam__Alignment_l_aux, file, "$;$");
        (void)newXS("Bio::DB::Bam::Alignment::aux", XS_Bio__DB__Bam__Alignment_aux, file);
        (void)newXSproto_portable("Bio::DB::Bam::Alignment::aux_get", XS_Bio__DB__Bam__Alignment_aux_get, file, "$$");
        (void)newXSproto_portable("Bio::DB::Bam::Alignment::aux_keys", XS_Bio__DB__Bam__Alignment_aux_keys, file, "$");
        (void)newXSproto_portable("Bio::DB::Bam::Alignment::data", XS_Bio__DB__Bam__Alignment_data, file, "$;$");
        (void)newXSproto_portable("Bio::DB::Bam::Alignment::data_len", XS_Bio__DB__Bam__Alignment_data_len, file, "$;$");
        (void)newXSproto_portable("Bio::DB::Bam::Alignment::m_data", XS_Bio__DB__Bam__Alignment_m_data, file, "$;$");
        (void)newXSproto_portable("Bio::DB::Bam::Alignment::qname", XS_Bio__DB__Bam__Alignment_qname, file, "$");
        (void)newXSproto_portable("Bio::DB::Bam::Alignment::paired", XS_Bio__DB__Bam__Alignment_paired, file, "$");
        (void)newXSproto_portable("Bio::DB::Bam::Alignment::proper_pair", XS_Bio__DB__Bam__Alignment_proper_pair, file, "$");
        (void)newXSproto_portable("Bio::DB::Bam::Alignment::unmapped", XS_Bio__DB__Bam__Alignment_unmapped, file, "$");
        (void)newXSproto_portable("Bio::DB::Bam::Alignment::munmapped", XS_Bio__DB__Bam__Alignment_munmapped, file, "$");
        (void)newXSproto_portable("Bio::DB::Bam::Alignment::reversed", XS_Bio__DB__Bam__Alignment_reversed, file, "$");
        (void)newXSproto_portable("Bio::DB::Bam::Alignment::mreversed", XS_Bio__DB__Bam__Alignment_mreversed, file, "$");
        (void)newXSproto_portable("Bio::DB::Bam::Alignment::cigar", XS_Bio__DB__Bam__Alignment_cigar, file, "$");
        (void)newXSproto_portable("Bio::DB::Bam::Header::new", XS_Bio__DB__Bam__Header_new, file, "$");
        (void)newXSproto_portable("Bio::DB::Bam::Header::n_targets", XS_Bio__DB__Bam__Header_n_targets, file, "$");
        (void)newXSproto_portable("Bio::DB::Bam::Header::target_name", XS_Bio__DB__Bam__Header_target_name, file, "$");
        (void)newXSproto_portable("Bio::DB::Bam::Header::target_len", XS_Bio__DB__Bam__Header_target_len, file, "$");
        (void)newXS("Bio::DB::Bam::Header::text", XS_Bio__DB__Bam__Header_text, file);
        (void)newXSproto_portable("Bio::DB::Bam::Header::parse_region", XS_Bio__DB__Bam__Header_parse_region, file, "$");
        (void)newXSproto_portable("Bio::DB::Bam::Header::view1", XS_Bio__DB__Bam__Header_view1, file, "$$");
        (void)newXSproto_portable("Bio::DB::Bam::Header::DESTROY", XS_Bio__DB__Bam__Header_DESTROY, file, "$");
        (void)newXS("Bio::DB::Bam::Index::fetch", XS_Bio__DB__Bam__Index_fetch, file);
        (void)newXS("Bio::DB::Bam::Index::lpileup", XS_Bio__DB__Bam__Index_lpileup, file);
        (void)newXS("Bio::DB::Bam::Index::pileup", XS_Bio__DB__Bam__Index_pileup, file);
        (void)newXS("Bio::DB::Bam::Index::coverage", XS_Bio__DB__Bam__Index_coverage, file);
        (void)newXS("Bio::DB::Bam::Index::DESTROY", XS_Bio__DB__Bam__Index_DESTROY, file);
        (void)newXS("Bio::DB::Bam::Pileup::qpos", XS_Bio__DB__Bam__Pileup_qpos, file);
        (void)newXS("Bio::DB::Bam::Pileup::pos", XS_Bio__DB__Bam__Pileup_pos, file);
        (void)newXS("Bio::DB::Bam::Pileup::indel", XS_Bio__DB__Bam__Pileup_indel, file);
        (void)newXS("Bio::DB::Bam::Pileup::level", XS_Bio__DB__Bam__Pileup_level, file);
        (void)newXS("Bio::DB::Bam::Pileup::is_del", XS_Bio__DB__Bam__Pileup_is_del, file);
        (void)newXS("Bio::DB::Bam::Pileup::is_refskip", XS_Bio__DB__Bam__Pileup_is_refskip, file);
        (void)newXS("Bio::DB::Bam::Pileup::is_head", XS_Bio__DB__Bam__Pileup_is_head, file);
        (void)newXS("Bio::DB::Bam::Pileup::is_tail", XS_Bio__DB__Bam__Pileup_is_tail, file);
        (void)newXS("Bio::DB::Bam::Pileup::b", XS_Bio__DB__Bam__Pileup_b, file);
        (void)newXS("Bio::DB::Bam::Pileup::alignment", XS_Bio__DB__Bam__Pileup_alignment, file);
#if (PERL_REVISION == 5 && PERL_VERSION >= 9)
  if (PL_unitcheckav)
       call_list(PL_scopestack_ix, PL_unitcheckav);
#endif
    XSRETURN_YES;
}

