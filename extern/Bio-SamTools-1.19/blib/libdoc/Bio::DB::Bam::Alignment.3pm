.\" Automatically generated by Pod::Man 2.16 (Pod::Simple 3.05)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::DB::Bam::Alignment 3"
.TH Bio::DB::Bam::Alignment 3 "2010-05-28" "perl v5.10.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Bio::DB::Bam::Alignment \-\- The SAM/BAM alignment object
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use Bio::DB::Sam;
\&
\& my $sam = Bio::DB::Sam\->new(\-fasta=>"data/ex1.fa",
\&                             \-bam  =>"data/ex1.bam");
\&
\& my @alignments = $sam\->get_features_by_location(\-seq_id => \*(Aqseq2\*(Aq,
\&                                                 \-start  => 500,
\&                                                 \-end    => 800);
\& for my $a (@alignments) {
\&    my $seqid  = $a\->seq_id;
\&    my $start  = $a\->start;
\&    my $end    = $a\->end;
\&    my $strand = $a\->strand;
\&    my $ref_dna= $a\->dna;
\&
\&    my $query_start  = $a\->query\->start;
\&    my $query_end    = $a\->query\->end;
\&    my $query_strand = $a\->query\->strand;
\&    my $query_dna    = $a\->query\->dna;
\&   
\&    my $cigar     = $a\->cigar_str;
\&    my @scores    = $a\->qscore;     # per\-base quality scores
\&    my $match_qual= $a\->qual;       # quality of the match
\&
\&    my $paired = $a\->get_tag_values(\*(AqPAIRED\*(Aq);
\& }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The Bio::DB::Bam::Alignment and Bio::DB::Bam::AlignWrapper classes
together represent an alignment between a sequence read (the \*(L"query\*(R")
and a reference sequence (the \*(L"target\*(R"). Bio::DB::Bam::Alignment
adheres strictly to the C\-level \s-1BAM\s0 library's definition of a bam1_t*
and is used in the Bio::DB::Sam low-level \s-1API\s0 The latter adds
convenience methods that make it similar to a BioPerl Bio::SeqFeatureI
object. This manual page describes both.
.SH "High-level Bio::DB::Bam::Alignment methods"
.IX Header "High-level Bio::DB::Bam::Alignment methods"
These methods are provided by Bio::DB::Bam::Alignment, and are
intended to be compatible with the Bio::SeqFeatureI interfaces. Note
that these objects are \fBnot\fR compatible with Bio::Align::AlignI, as
the \s-1BAM\s0 \s-1API\s0 is fundamentally incompatible with the BioPerl \s-1API\s0 for
alignments (the first deals with the alignment of a single read
against the reference sequence, while the second deals with a multiple
alignment).
.PP
Note that the high-level \s-1API\s0 return Bio::DB::Bam::AlignWrapper objects
\&\fBexcept\fR in the case of the callback to the \fIfast_pileup()\fR method. In
this case only, the object returned by calling \f(CW$pileup\fR\->b() is a
Bio::DB::Bam::Alignment object for performance reasons.
.ie n .IP "$seq_id\fR = \f(CW$align\->seq_id" 4
.el .IP "\f(CW$seq_id\fR = \f(CW$align\fR\->seq_id" 4
.IX Item "$seq_id = $align->seq_id"
Return the seq_id of the reference (target) sequence. This method is only
available in the Bio::DB::Bam::AlignWrapper extension.
.ie n .IP "$start\fR = \f(CW$align\->start" 4
.el .IP "\f(CW$start\fR = \f(CW$align\fR\->start" 4
.IX Item "$start = $align->start"
Return the start of the alignment in 1\-based reference sequence
coordinates.
.ie n .IP "$end\fR = \f(CW$align\->end" 4
.el .IP "\f(CW$end\fR = \f(CW$align\fR\->end" 4
.IX Item "$end = $align->end"
Return the end of the alignment in 1\-based reference sequence
coordinates.
.ie n .IP "$len\fR = \f(CW$align\->length" 4
.el .IP "\f(CW$len\fR = \f(CW$align\fR\->length" 4
.IX Item "$len = $align->length"
Return the length of the alignment on the reference sequence.
.ie n .IP "$strand\fR = \f(CW$align\->strand" 4
.el .IP "\f(CW$strand\fR = \f(CW$align\fR\->strand" 4
.IX Item "$strand = $align->strand"
Return the strand of the alignment as \-1 for reversed, +1 for
forward.
.Sp
\&\s-1NOTE:\s0 In versions 1.00\-1.06, this method always returned +1. As of
version 1.07, this behavior is fixed.
.ie n .IP "$mstrand\fR = \f(CW$align\->mstrand" 4
.el .IP "\f(CW$mstrand\fR = \f(CW$align\fR\->mstrand" 4
.IX Item "$mstrand = $align->mstrand"
If the read has a mate pair, return the strand of the mate in the
format \-1 or +1.
.ie n .IP "$ref_dna\fR        = \f(CW$align\->dna" 4
.el .IP "\f(CW$ref_dna\fR        = \f(CW$align\fR\->dna" 4
.IX Item "$ref_dna        = $align->dna"
Returns the \fBreference\fR sequence's \s-1DNA\s0 across the aligned region. If
an \s-1MD\s0 tag is present in the alignment, it will be used preferentially
to reconstruct the reference sequence. Otherwise the reference \s-1DNA\s0
access object passed to Bio::DB::Sam\->\fInew()\fR will be used.
.ie n .IP "$ref_dna\fR        = \f(CW$align\->seq" 4
.el .IP "\f(CW$ref_dna\fR        = \f(CW$align\fR\->seq" 4
.IX Item "$ref_dna        = $align->seq"
The \fBreference\fR sequence's \s-1DNA\s0 as a Bio::PrimarySeqI object (useful
for passing to BioPerl functions and for calculating subsequences and
reverse complements).
.ie n .IP "$query\fR = \f(CW$align\->query" 4
.el .IP "\f(CW$query\fR = \f(CW$align\fR\->query" 4
.IX Item "$query = $align->query"
This method returns a Bio::DB::Alignment::Query object that can be
used to retrieve information about the query sequence. The next few
entries show how to use this object.
.ie n .IP "$read_name\fR = \f(CW$align\->query\->name" 4
.el .IP "\f(CW$read_name\fR = \f(CW$align\fR\->query\->name" 4
.IX Item "$read_name = $align->query->name"
The name of the read.
.ie n .IP "$q_start\fR   = \f(CW$align\->query\->start" 4
.el .IP "\f(CW$q_start\fR   = \f(CW$align\fR\->query\->start" 4
.IX Item "$q_start   = $align->query->start"
This returns the start position of the query (read) sequence in
1\-based coordinates. It acts via a transient Bio::DB::Bam::Query
object that is provided for Bio::Graphics compatibility (see
Bio::Graphics).
.ie n .IP "$q_end\fR     = \f(CW$align\->query\->end" 4
.el .IP "\f(CW$q_end\fR     = \f(CW$align\fR\->query\->end" 4
.IX Item "$q_end     = $align->query->end"
This returns the end position of the query sequence in 1\-based
coordinates.
.ie n .IP "$q_len\fR     = \f(CW$align\->query\->length" 4
.el .IP "\f(CW$q_len\fR     = \f(CW$align\fR\->query\->length" 4
.IX Item "$q_len     = $align->query->length"
Return the length of the alignment on the read.
.ie n .IP "$scores\fR = \f(CW$align\->query\->score" 4
.el .IP "\f(CW$scores\fR = \f(CW$align\fR\->query\->score" 4
.IX Item "$scores = $align->query->score"
Return an array reference containing the unpacked quality scores for
each base of the query sequence. The length of this array reference
will be equal to the length of the read.
.ie n .IP "$read_dna\fR = \f(CW$align\->query\->dna" 4
.el .IP "\f(CW$read_dna\fR = \f(CW$align\fR\->query\->dna" 4
.IX Item "$read_dna = $align->query->dna"
The read's \s-1DNA\s0 string.
.ie n .IP "$read_seq\fR = \f(CW$align\->query\->seq" 4
.el .IP "\f(CW$read_seq\fR = \f(CW$align\fR\->query\->seq" 4
.IX Item "$read_seq = $align->query->seq"
The read's \s-1DNA\s0 as a Bio::PrimarySeqI object.
.ie n .IP "$target\fR  = \f(CW$align\->target;" 4
.el .IP "\f(CW$target\fR  = \f(CW$align\fR\->target;" 4
.IX Item "$target  = $align->target;"
The \fItarget()\fR method is similar to \fIquery()\fR, except that it follows
Bio::AlignIO conventions for how to represent minus strand
alignments. The object returned has \fIstart()\fR, \fIend()\fR, \fIqscore()\fR, \fIdna()\fR
and \fIseq()\fR methods, but for minus strand alignments the sequence will
be represented as it appears on the reverse strand, rather than on the
forward strand. This has the advantage of giving you the read as it
came off the machine, before being reverse complemented for use in the
\&\s-1SAM\s0 file.
.ie n .IP "$query\fR   = \f(CW$align\->hit" 4
.el .IP "\f(CW$query\fR   = \f(CW$align\fR\->hit" 4
.IX Item "$query   = $align->hit"
The \fIhit()\fR method is identical to \fItarget()\fR and returns information
about the read. It is present for compatibility with some of the
Bio::Graphics glyphs, which use \fIhit()\fR to represent the non-reference
sequence in aligned sequences.
.ie n .IP "$primary_id\fR = \f(CW$align\->primary_id" 4
.el .IP "\f(CW$primary_id\fR = \f(CW$align\fR\->primary_id" 4
.IX Item "$primary_id = $align->primary_id"
This method synthesizes a unique \s-1ID\s0 for the alignment which can be
passed to \f(CW$sam\fR\->\fIget_feature_by_id()\fR to retrieve the alignment at a
later date.
.ie n .IP "@tags\fR = \f(CW$align\->get_all_tags" 4
.el .IP "\f(CW@tags\fR = \f(CW$align\fR\->get_all_tags" 4
.IX Item "@tags = $align->get_all_tags"
Return all tag names known to this alignment. This includes \s-1SAM\s0 flags
such as M_UNMAPPED, as well as auxiliary flags such as H0. The
behavior of this method depends on the value of \-expand_flags when the
\&\s-1SAM\s0 object was created. If false (the default), then the standard \s-1SAM\s0
flags will be concatenated together into a single string and stored in
a tag named '\s-1FLAGS\s0'. The format of this tag value is the list of one
or more flag constants separated by the \*(L"|\*(R" character, as in:
\&\*(L"PAIRED|MAP_PAIR|REVERSED|SECOND_MATE\*(R". If \-expand_flags was true,
then each flag becomes its own named tag, such as \*(L"\s-1MAP_PAIR\s0\*(R".
.ie n .IP "@values\fR = \f(CW$align\->get_tag_values($tag)" 4
.el .IP "\f(CW@values\fR = \f(CW$align\fR\->get_tag_values($tag)" 4
.IX Item "@values = $align->get_tag_values($tag)"
Given a tag name, such as '\s-1PAIRED\s0' or 'H0', return its
value(s). \-expand_flags must be true in order to use the standard \s-1SAM\s0
flag constants as tags. Otherwise, they can be fetched by asking for
the \*(L"\s-1FLAGS\s0\*(R" tag, or by using the low-level methods described below.
.ie n .IP "$is_true\fR = \f(CW$align\->has_tag($tag)" 4
.el .IP "\f(CW$is_true\fR = \f(CW$align\fR\->has_tag($tag)" 4
.IX Item "$is_true = $align->has_tag($tag)"
Return true if the alignment has the indicated tag.
.ie n .IP "$string\fR = \f(CW$align\->cigar_str" 4
.el .IP "\f(CW$string\fR = \f(CW$align\fR\->cigar_str" 4
.IX Item "$string = $align->cigar_str"
Return the \s-1CIGAR\s0 string for this alignment in conventional human
readable format (e.g. \*(L"M34D1M1\*(R").
.ie n .IP "$arrayref\fR = \f(CW$align\->cigar_array" 4
.el .IP "\f(CW$arrayref\fR = \f(CW$align\fR\->cigar_array" 4
.IX Item "$arrayref = $align->cigar_array"
Return a reference to an array representing the \s-1CIGAR\s0 string. This is
an array of arrays, in which each subarray consists of a \s-1CIGAR\s0
operation and a count. Example:
.Sp
.Vb 1
\& [ [\*(AqM\*(Aq,34], [\*(AqD\*(Aq,1], [\*(AqM1\*(Aq,1] ]
.Ve
.ie n .IP "($ref,$matches,$query) = $align\->padded_alignment" 4
.el .IP "($ref,$matches,$query) = \f(CW$align\fR\->padded_alignment" 4
.IX Item "($ref,$matches,$query) = $align->padded_alignment"
Return three strings that show the alignment between the reference
sequence (the target) and the query. It will look like this:
.Sp
.Vb 3
\& $ref     AGTGCCTTTGTTCA\-\-\-\-\-ACCCCCTTGCAACAACC
\& $matches ||||||||||||||     |||||||||||||||||
\& $query   AGTGCCTTTGTTCACATAGACCCCCTTGCAACAACC
.Ve
.ie n .IP "$str\fR = \f(CW$align\->aux" 4
.el .IP "\f(CW$str\fR = \f(CW$align\fR\->aux" 4
.IX Item "$str = $align->aux"
Returns the text version of the \s-1SAM\s0 tags, e.g. 
\&\*(L"\s-1XT:A:M\s0 NM:i:2 SM:i:37 AM:i:37 XM:i:1 XO:i:1 XG:i:1 MD:Z:6^C0A47\*(R"
.ie n .IP "$str\fR = \f(CW$align\->tam_line" 4
.el .IP "\f(CW$str\fR = \f(CW$align\fR\->tam_line" 4
.IX Item "$str = $align->tam_line"
Returns the \s-1TAM\s0 (text) representation of the alignment (available in
the high-level \*(L"AlignWrapper\*(R" interface only).
.ie n .IP "$tag\fR = \f(CW$align\->primary_tag" 4
.el .IP "\f(CW$tag\fR = \f(CW$align\fR\->primary_tag" 4
.IX Item "$tag = $align->primary_tag"
This is provided for Bio::SeqFeatureI compatibility. Return the string
\&\*(L"match\*(R".
.ie n .IP "$tag\fR = \f(CW$align\->source_tag" 4
.el .IP "\f(CW$tag\fR = \f(CW$align\fR\->source_tag" 4
.IX Item "$tag = $align->source_tag"
This is provided for Bio::SeqFeatureI compatibility. Return the string
\&\*(L"sam/bam\*(R".
.ie n .IP "@parts\fR = \f(CW$align\->get_SeqFeatures" 4
.el .IP "\f(CW@parts\fR = \f(CW$align\fR\->get_SeqFeatures" 4
.IX Item "@parts = $align->get_SeqFeatures"
Return subfeatures of this alignment. If you have fetched a
\&\*(L"read_pair\*(R" feature, this will be the two mate pair objects (both of
type Bio::DB::Bam::AlignWrapper). If you have \-split_splices set to
true in the Bio::DB::Sam database, calling \fIget_SeqFeatures()\fR will
return the components of split alignments. See
\&\*(L"Bio::DB::Sam Constructor and basic accessors\*(R" in Bio::DB::Sam for an
example of how to use this.
.SH "Low-level Bio::DB::Bam::Alignment methods"
.IX Header "Low-level Bio::DB::Bam::Alignment methods"
These methods are available to objects of type Bio::DB::Bam::Alignment
as well as Bio::DB::Bam::AlignWrapper and closely mirror the native C
\&\s-1API\s0.
.ie n .IP "$align = Bio::DB::Bam::Alignment\->new" 4
.el .IP "\f(CW$align\fR = Bio::DB::Bam::Alignment\->new" 4
.IX Item "$align = Bio::DB::Bam::Alignment->new"
Create a new, empty alignment object. This is usually only needed when
iterating through a \s-1TAM\s0 file using Bio::DB::Tam\->\fIread1()\fR.
.ie n .IP "$tid\fR = \f(CW$align\->tid( [$new_tid] )" 4
.el .IP "\f(CW$tid\fR = \f(CW$align\fR\->tid( [$new_tid] )" 4
.IX Item "$tid = $align->tid( [$new_tid] )"
Return the target \s-1ID\s0 of the alignment. Optionally you may change the
tid by providing it as an argument (currently this is the only field
that you can change; the functionality was implemented as a proof of
principle).
.ie n .IP "$read_name\fR = \f(CW$align\->qname" 4
.el .IP "\f(CW$read_name\fR = \f(CW$align\fR\->qname" 4
.IX Item "$read_name = $align->qname"
Returns the name of the read.
.ie n .IP "$pos\fR = \f(CW$align\->pos" 4
.el .IP "\f(CW$pos\fR = \f(CW$align\fR\->pos" 4
.IX Item "$pos = $align->pos"
0\-based leftmost coordinate of the aligned sequence on the reference
sequence.
.ie n .IP "$end\fR = \f(CW$align\->calend" 4
.el .IP "\f(CW$end\fR = \f(CW$align\fR\->calend" 4
.IX Item "$end = $align->calend"
The 0\-based rightmost coordinate of the aligned sequence on the
reference sequence after taking alignment gaps into account.
.ie n .IP "$len\fR = \f(CW$align\->cigar2qlen" 4
.el .IP "\f(CW$len\fR = \f(CW$align\fR\->cigar2qlen" 4
.IX Item "$len = $align->cigar2qlen"
The length of the query sequence calculated from the \s-1CIGAR\s0 string.
.ie n .IP "$quality\fR = \f(CW$align\->qual" 4
.el .IP "\f(CW$quality\fR = \f(CW$align\fR\->qual" 4
.IX Item "$quality = $align->qual"
The quality score for the alignment as a whole.
.ie n .IP "$flag\fR = \f(CW$align\->flag" 4
.el .IP "\f(CW$flag\fR = \f(CW$align\fR\->flag" 4
.IX Item "$flag = $align->flag"
The bitwise flag field (see the \s-1SAM\s0 documentation).
.ie n .IP "$n_cigar\fR = \f(CW$align\->n_cigar" 4
.el .IP "\f(CW$n_cigar\fR = \f(CW$align\fR\->n_cigar" 4
.IX Item "$n_cigar = $align->n_cigar"
Number of \s-1CIGAR\s0 operations in this alignment.
.ie n .IP "$length\fR = \f(CW$align\->l_qseq" 4
.el .IP "\f(CW$length\fR = \f(CW$align\fR\->l_qseq" 4
.IX Item "$length = $align->l_qseq"
The length of the query sequence (the read).
.ie n .IP "$dna\fR = \f(CW$align\->qseq" 4
.el .IP "\f(CW$dna\fR = \f(CW$align\fR\->qseq" 4
.IX Item "$dna = $align->qseq"
The actual \s-1DNA\s0 sequence of the query. As in the \s-1SAM\s0 file, reads that
are aligned to the minus strand of the reference are returned in
reverse complemented form.
.ie n .IP "$score_str\fR = \f(CW$align\->_qscore" 4
.el .IP "\f(CW$score_str\fR = \f(CW$align\fR\->_qscore" 4
.IX Item "$score_str = $align->_qscore"
A packed binary string containing the quality scores for each base of
the read. It will be the same length as the \s-1DNA\s0. You may unpack it
using unpack('C*',$score_str), or use the high-level \fIqscore()\fR method.
.ie n .IP "$score_arry\fR = \f(CW$align\->qscore" 4
.el .IP "\f(CW$score_arry\fR = \f(CW$align\fR\->qscore" 4
.IX Item "$score_arry = $align->qscore"
.PD 0
.ie n .IP "@score_arry\fR = \f(CW$align\->qscore" 4
.el .IP "\f(CW@score_arry\fR = \f(CW$align\fR\->qscore" 4
.IX Item "@score_arry = $align->qscore"
.PD
In a scalar context return an array reference containing the unpacked
quality scores for each base of the query sequence. In a list context
return a list of the scores. This array is in the same orientation as
the reference sequence.
.ie n .IP "$length\fR = \f(CW$align\->isize" 4
.el .IP "\f(CW$length\fR = \f(CW$align\fR\->isize" 4
.IX Item "$length = $align->isize"
The calculated insert size for mapped paired reads.
.ie n .IP "$length\fR = \f(CW$align\->l_aux" 4
.el .IP "\f(CW$length\fR = \f(CW$align\fR\->l_aux" 4
.IX Item "$length = $align->l_aux"
The length of the align \*(L"auxiliary\*(R" data.
.ie n .IP "$value\fR = \f(CW$align\->aux_get(""tag"")" 4
.el .IP "\f(CW$value\fR = \f(CW$align\fR\->aux_get(``tag'')" 4
.IX Item "$value = $align->aux_get(tag)"
Given an auxiliary tag, such as \*(L"H0\*(R", return its value.
.ie n .IP "@keys\fR  = \f(CW$align\->aux_keys" 4
.el .IP "\f(CW@keys\fR  = \f(CW$align\fR\->aux_keys" 4
.IX Item "@keys  = $align->aux_keys"
Return the list of auxiliary tags known to this alignment.
.ie n .IP "$data\fR = \f(CW$align\->data" 4
.el .IP "\f(CW$data\fR = \f(CW$align\fR\->data" 4
.IX Item "$data = $align->data"
Return a packed string containing the alignment data (sequence,
quality scores and cigar string).
.ie n .IP "$length\fR = \f(CW$align\->data_len" 4
.el .IP "\f(CW$length\fR = \f(CW$align\fR\->data_len" 4
.IX Item "$length = $align->data_len"
Return the current length of the alignment data.
.ie n .IP "$length\fR = \f(CW$align\->m_data" 4
.el .IP "\f(CW$length\fR = \f(CW$align\fR\->m_data" 4
.IX Item "$length = $align->m_data"
Return the maximum length of the alignment data.
.ie n .IP "$is_paired\fR = \f(CW$align\->paired" 4
.el .IP "\f(CW$is_paired\fR = \f(CW$align\fR\->paired" 4
.IX Item "$is_paired = $align->paired"
Return true if the aligned read is part of a mate/read pair
(regardless of whether the mate mapped).
.ie n .IP "$is_proper\fR = \f(CW$align\->proper_pair" 4
.el .IP "\f(CW$is_proper\fR = \f(CW$align\fR\->proper_pair" 4
.IX Item "$is_proper = $align->proper_pair"
Return true if the aligned read is part of a mate/read pair and both
partners mapped to the reference sequence.
.ie n .IP "$is_unmapped\fR = \f(CW$align\->unmapped" 4
.el .IP "\f(CW$is_unmapped\fR = \f(CW$align\fR\->unmapped" 4
.IX Item "$is_unmapped = $align->unmapped"
Return true if the read failed to align.
.ie n .IP "$mate_is_unmapped\fR = \f(CW$align\->munmapped" 4
.el .IP "\f(CW$mate_is_unmapped\fR = \f(CW$align\fR\->munmapped" 4
.IX Item "$mate_is_unmapped = $align->munmapped"
Return true if the read's mate failed to align.
.ie n .IP "$reversed\fR = \f(CW$align\->reversed" 4
.el .IP "\f(CW$reversed\fR = \f(CW$align\fR\->reversed" 4
.IX Item "$reversed = $align->reversed"
Return true if the aligned read was reverse complemented prior to
aligning.
.ie n .IP "$mate_reversed\fR = \f(CW$align\->mreversed" 4
.el .IP "\f(CW$mate_reversed\fR = \f(CW$align\fR\->mreversed" 4
.IX Item "$mate_reversed = $align->mreversed"
Return true if the aligned read's mate was reverse complemented prior
to aligning.
.ie n .IP "$mseqid\fR  = \f(CW$align\->mate_seq_id" 4
.el .IP "\f(CW$mseqid\fR  = \f(CW$align\fR\->mate_seq_id" 4
.IX Item "$mseqid  = $align->mate_seq_id"
Return the seqid of the mate.
.ie n .IP "$mstart\fR  = \f(CW$align\->mate_start" 4
.el .IP "\f(CW$mstart\fR  = \f(CW$align\fR\->mate_start" 4
.IX Item "$mstart  = $align->mate_start"
For paired reads, return the start of the mate's alignment in
reference sequence coordinates.
.ie n .IP "$mend\fR  = \f(CW$align\->mate_end" 4
.el .IP "\f(CW$mend\fR  = \f(CW$align\fR\->mate_end" 4
.IX Item "$mend  = $align->mate_end"
For paired reads, return the end position of the mate's alignment. in
reference sequence coordinates.
.Sp
\&\-item \f(CW$len\fR   = \f(CW$align\fR\->mate_len
.Sp
For mate-pairs, retrieve the length of the mate's alignment on the
reference sequence.
.ie n .IP "$isize\fR = \f(CW$align\->isize" 4
.el .IP "\f(CW$isize\fR = \f(CW$align\fR\->isize" 4
.IX Item "$isize = $align->isize"
For mate-pairs, return the computed insert size.
.ie n .IP "$arrayref\fR = \f(CW$align\->cigar" 4
.el .IP "\f(CW$arrayref\fR = \f(CW$align\fR\->cigar" 4
.IX Item "$arrayref = $align->cigar"
This returns the \s-1CIGAR\s0 data in its native \s-1BAM\s0 format. You will receive
an arrayref in which each operation and count are packed together into
an 8\-bit structure. To decode each element you must use the following
operations:
.Sp
.Vb 4
\& use Bio::DB::Sam::Constants;
\& my $c   = $align\->cigar;
\& my $op  = $c\->[0] & BAM_CIGAR_MASK;
\& my $len = $c\->[0] >> BAM_CIGAR_SHIFT;
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Bio::Perl, Bio::DB::Sam, Bio::DB::Bam::Constants
.SH "AUTHOR"
.IX Header "AUTHOR"
Lincoln Stein <lincoln.stein@oicr.on.ca>.
<lincoln.stein@bmail.com>
.PP
Copyright (c) 2009 Ontario Institute for Cancer Research.
.PP
This package and its accompanying libraries is free software; you can
redistribute it and/or modify it under the terms of the \s-1GPL\s0 (either
version 1, or at your option, any later version) or the Artistic
License 2.0.  Refer to \s-1LICENSE\s0 for the full license text. In addition,
please see \s-1DISCLAIMER\s0.txt for disclaimers of warranty.
