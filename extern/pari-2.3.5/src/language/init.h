/* This file is autogenerated from the database. */
/* See src/desc/gen_proto */
/* Do not edit*/
entree functions_basic[]={
{"Col",0,(void*)gtocol,2,"DG","Col({x=[]}): transforms the object x into a column vector. Empty vector if x is omitted"},
{"Euler",0,(void*)mpeuler,3,"p","Euler=Euler(): Euler's constant with current precision"},
{"I",0,(void*)geni,3,"","I=I(): square root of -1"},
{"List",0,(void*)gtolist,2,"DG","List({x=[]}): transforms the vector or list x into a list. Empty list if x is omitted"},
{"Mat",0,(void*)gtomat,2,"DG","Mat({x=[]}): transforms any GEN x into a matrix. Empty matrix if x is omitted"},
{"Mod",0,(void*)Mod0,2,"GGD0,L,","Mod(x,y): creates 'x modulo y'."},
{"O",50,NULL,7,NULL,"O(a^b): p-adic or power series zero with precision given by b"},
{"Pi",0,(void*)mppi,3,"p","Pi=Pi(): the constant pi, with current precision"},
{"Pol",0,(void*)gtopoly,2,"GDn","Pol(x,{v=x}): convert x (usually a vector or a power series) into a polynomial with variable v, starting with the leading coefficient"},
{"Polrev",0,(void*)gtopolyrev,2,"GDn","Polrev(x,{v=x}): convert x (usually a vector or a power series) into a polynomial with variable v, starting with the constant term"},
{"Qfb",0,(void*)Qfb0,2,"GGGDGp","Qfb(a,b,c,{D=0.}): binary quadratic form a*x^2+b*x*y+c*y^2. D is optional (0.0 by default) and initializes Shanks's distance if b^2-4*a*c>0"},
{"Ser",0,(void*)gtoser,2,"GDn","Ser(x,{v=x}): convert x (usually a vector) into a power series with variable v, starting with the constant coefficient"},
{"Set",0,(void*)gtoset,2,"DG","Set({x=[]}): convert x into a set, i.e. a row vector with strictly increasing coefficients. Empty set if x is omitted"},
{"Str",0,(void*)Str,2,"s*","Str({str}*): concatenates its (string) argument into a single string"},
{"Strchr",1,(void*)Strchr,2,"G","Strchr(x): converts x to a string, translating each integer into a character"},
{"Strexpand",0,(void*)Strexpand,2,"s*","Strexpand({str}*): concatenates its (string) argument into a single string, performing tilde expansion"},
{"Strtex",0,(void*)Strtex,2,"s*","Strtex({str}*): translates its (string) arguments to TeX format and returns the resulting string"},
{"Vec",0,(void*)gtovec,2,"DG","Vec({x=[]}): transforms the object x into a vector. Empty vector if x is omitted"},
{"Vecsmall",0,(void*)gtovecsmall,2,"DG","Vecsmall({x=[]}): transforms the object x into a VECSMALL. Empty vector if x is omitted"},
{"abs",0,(void*)gabs,3,"Gp","abs(x): absolute value (or modulus) of x"},
{"acos",0,(void*)gacos,3,"Gp","acos(x): inverse cosine of x"},
{"acosh",0,(void*)gach,3,"Gp","acosh(x): inverse hyperbolic cosine of x"},
{"addhelp",1,(void*)addhelp,11,"vSs","addhelp(symbol,\"message\"): add/change help message for a symbol"},
{"addprimes",0,(void*)addprimes,4,"DG","addprimes({x=[]}): add primes in the vector x to the prime table to be used in trial division. x may also be a single integer. Composite \"primes\" are allowed, and in that case you may later get a message \"impossible inverse\", which will give you some factors. List the current extra primes if x is omitted. If some primes are added which intersect non trivially the existing table entries, suitable updating is done"},
{"agm",0,(void*)agm,3,"GGp","agm(x,y): arithmetic-geometric mean of x and y"},
{"algdep",0,(void*)algdep0,8,"GLD0,L,p","algdep(x,n,{flag=0}): algebraic relations up to degree n of x, using lindep([1,x,...,x^(n-1)], flag)."},
{"alias",1,(void*)alias0,11,"vrr","alias(\"new\",\"old\"): new is now an alias for old"},
{"allocatemem",0,(void*)allocatemem0,11,"vD0,L,","allocatemem({s=0}): allocates a new stack of s bytes. doubles the stack if s is omitted"},
{"arg",0,(void*)garg,3,"Gp","arg(x): argument of x,such that -pi<arg(x)<=pi"},
{"asin",0,(void*)gasin,3,"Gp","asin(x): inverse sine of x"},
{"asinh",0,(void*)gash,3,"Gp","asinh(x): inverse hyperbolic sine of x"},
{"atan",0,(void*)gatan,3,"Gp","atan(x): inverse tangent of x"},
{"atanh",0,(void*)gath,3,"Gp","atanh(x): inverse hyperbolic tangent of x"},
{"bernfrac",1,(void*)bernfrac,3,"L","bernfrac(x): Bernoulli number B_x, as a rational number"},
{"bernreal",0,(void*)bernreal,3,"Lp","bernreal(x): Bernoulli number B_x, as a real number with the current precision"},
{"bernvec",1,(void*)bernvec,3,"L","bernvec(x): Vector of rational Bernoulli numbers B_0, B_2,...up to B_(2x)"},
{"besselh1",0,(void*)hbessel1,3,"GGp","besselh1(nu,x): H^1-bessel function of index nu and argument x"},
{"besselh2",0,(void*)hbessel2,3,"GGp","besselh2(nu,x): H^2-bessel function of index nu and argument x"},
{"besseli",0,(void*)ibessel,3,"GGp","besseli(nu,x): I-bessel function of index nu and argument x"},
{"besselj",0,(void*)jbessel,3,"GGp","besselj(nu,x): J-bessel function of index nu and argument x"},
{"besseljh",0,(void*)jbesselh,3,"GGp","besseljh(n,x): J-bessel function of index n+1/2 and argument x, where n is a non-negative integer"},
{"besselk",0,(void*)kbessel0,3,"GGD0,L,p","besselk(nu,x,{flag=0}): K-bessel function of index nu and argument x (x positive real of type real, nu of any scalar type). flag is optional, and may be set to 0: default; 1: use hyperu"},
{"besseln",0,(void*)nbessel,3,"GGp","besseln(nu,x): N-bessel function of index nu and argument x"},
{"bestappr",0,(void*)bestappr0,4,"GGDG","bestappr(x,k): gives the best approximation to the real x with denominator less or equal to k"},
{"bezout",1,(void*)vecbezout,4,"GG","bezout(x,y): gives a 3-dimensional row vector [u,v,d] such that d=gcd(x,y) and u*x+v*y=d"},
{"bezoutres",1,(void*)vecbezoutres,4,"GG","bezoutres(x,y): gives a 3-dimensional row vector [u,v,d] such that d=resultant(x,y) and u*x+v*y=d, where x and y are polynomials"},
{"bigomega",1,(void*)gbigomega,4,"G","bigomega(x): number of prime divisors of x, counted with multiplicity"},
{"binary",1,(void*)binaire,2,"G","binary(x): gives the vector formed by the binary digits of x (x integer)"},
{"binomial",1,(void*)binomial,4,"GL","binomial(x,y): binomial coefficient x*(x-1)...*(x-y+1)/y! defined for y in Z and any x"},
{"bitand",1,(void*)gbitand,2,"GG","bitand(x,y): bitwise \"and\" of two integers x and y. Negative numbers behave as if modulo big power of 2"},
{"bitneg",0,(void*)gbitneg,2,"GD-1,L,","bitneg(x,{n=-1}): bitwise negation of an integers x truncated to n bits. n=-1 means represent infinite sequences of bit 1 as negative numbers. Negative numbers behave as if modulo big power of 2"},
{"bitnegimply",1,(void*)gbitnegimply,2,"GG","bitnegimply(x,y): bitwise \"negated imply\" of two integers x and y, in other words, x BITAND BITNEG(y). Negative numbers behave as if modulo big power of 2"},
{"bitor",1,(void*)gbitor,2,"GG","bitor(x,y): bitwise \"or\" of two integers x and y. Negative numbers behave as if modulo big power of 2"},
{"bittest",1,(void*)gbittest,2,"GG","bittest(x,n): gives bit number n (coefficient of 2^n) of the integer x. Negative numbers behave as if modulo big power of 2"},
{"bitxor",1,(void*)gbitxor,2,"GG","bitxor(x,y): bitwise \"exclusive or\" of two integers x and y. Negative numbers behave as if modulo big power of 2"},
{"bnfcertify",1,(void*)certifybuchall,6,"lG","bnfcertify(bnf): certify the correctness (i.e. remove the GRH) of the bnf data output by bnfclassunit or bnfinit"},
{"bnfclassunit",0,(void*)bnfclassunit0,6,"GD0,L,DGp","bnfclassunit(P,{flag=0},{tech=[]}): compute the class group, regulator of the number field defined by the polynomial P, and also the fundamental units if they are not too large. flag and tech are both optional. flag can be any of 0: default, 1: insist on having fundamental units, 2: do not compute units. See manual for details about tech. P may also be a non-zero integer, and is then considered as the discriminant of a quadratic order"},
{"bnfclgp",0,(void*)classgrouponly,6,"GDGp","bnfclgp(P,{tech=[]}): compute the class group of the number field defined by the polynomial P. If P is a non-zero integer, it is interpreted as a quadratic discriminant. See manual for details about tech"},
{"bnfdecodemodule",1,(void*)decodemodule,6,"GG","bnfdecodemodule(nf,fa): given a coded module fa as in bnrdisclist, gives the true module"},
{"bnfinit",0,(void*)bnfinit0,6,"GD0,L,DGp","bnfinit(P,{flag=0},{tech=[]}): compute the necessary data for future use in ideal and unit group computations, including fundamental units if they are not too large. flag and tech are both optional. flag can be any of 0: default, 1: insist on having fundamental units, 2: do not compute units, 3: small bnfinit, which can be converted to a big one using bnfmake. See manual for details about tech"},
{"bnfisintnorm",1,(void*)bnfisintnorm,6,"GG","bnfisintnorm(bnf,x): compute a complete system of solutions (modulo units of positive norm) of the absolute norm equation N(a)=x, where a belongs to the maximal order of big number field bnf (if bnf is not certified, this depends on GRH)"},
{"bnfisnorm",0,(void*)bnfisnorm,6,"GGD1,L,p","bnfisnorm(bnf,x,{flag=1}): Tries to tell whether x (in Q) is the norm of some fractional y (in bnf). Returns a vector [a,b] where x=Norm(a)*b. Looks for a solution which is a S-unit, with S a certain list of primes (in bnf) containing (among others) all primes dividing x. If bnf is known to be Galois, set flag=0 (in this case, x is a norm iff b=1). If flag is non zero the program adds to S all the primes : dividing flag if flag<0, or less than flag if flag>0. The answer is guaranteed (i.e x norm iff b=1) under GRH, if S contains all primes less than 12.log(disc(Bnf))^2, where Bnf is the Galois closure of bnf"},
{"bnfisprincipal",0,(void*)isprincipalall,6,"GGD1,L,","bnfisprincipal(bnf,x,{flag=1}): bnf being output by bnfinit (with flag<=2), gives [v,alpha], where v is the vector of exponents on the class group generators and alpha is the generator of the resulting principal ideal. In particular x is principal if and only if v is the zero vector. flag is optional, whose meaning is: 0: output only v; 1: default; 2: output only v, precision being doubled until the result is obtained; 3: as 2 but output generators"},
{"bnfissunit",1,(void*)bnfissunit,6,"GGG","bnfissunit(bnf,sfu,x): bnf being output by bnfinit (with flag<=2), sfu by bnfsunit, gives the column vector of exponents of x on the fundamental S-units and the roots of unity if x is a unit, the empty vector otherwise"},
{"bnfisunit",1,(void*)isunit,6,"GG","bnfisunit(bnf,x): bnf being output by bnfinit (with flag<=2), gives the column vector of exponents of x on the fundamental units and the roots of unity if x is a unit, the empty vector otherwise"},
{"bnfmake",0,(void*)bnfmake,6,"Gp","bnfmake(sbnf): transforms small sbnf as output by bnfinit with flag=3 into a true big bnf"},
{"bnfnarrow",1,(void*)buchnarrow,6,"G","bnfnarrow(bnf): given a big number field as output by bnfinit, gives as a 3-component vector the structure of the narrow class group"},
{"bnfreg",0,(void*)regulator,6,"GDGp","bnfreg(P,{tech=[]}): compute the regulator of the number field defined by the polynomial P. If P is a non-zero integer, it is interpreted as a quadratic discriminant. See manual for details about tech"},
{"bnfsignunit",1,(void*)signunits,6,"G","bnfsignunit(bnf): matrix of signs of the real embeddings of the system of fundamental units found by bnfinit"},
{"bnfsunit",0,(void*)bnfsunit,6,"GGp","bnfsunit(bnf,S): compute the fundamental S-units of the number field bnf output by bnfinit, S being a list of prime ideals. res[1] contains the S-units, res[5] the S-classgroup. See manual for details"},
{"bnfunit",1,(void*)buchfu,6,"G","bnfunit(bnf): compute the fundamental units of the number field bnf output by bnfinit when they have not yet been computed (i.e. with flag=2)"},
{"bnrL1",0,(void*)bnrL1,6,"GDGD0,L,p","bnrL1(bnr, {subgroup}, {flag=0}): bnr being output by bnrinit(,,1) and subgroup being a square matrix defining a congruence subgroup of bnr (the trivial subgroup if omitted), for each character of bnr trivial on this subgroup, compute L(1, chi) (or equivalently the first non-zero term c(chi) of the expansion at s = 0). The binary digits of flag mean 1: if 0 then compute the term c(chi) and return [r(chi), c(chi)] where r(chi) is the order of L(s, chi) at s = 0, or if 1 then compute the value at s = 1 (and in this case, only for non-trivial characters), 2: if 0 then compute the value of the primitive L-function associated to chi, if 1 then compute the value of the L-function L_S(s, chi) where S is the set of places dividing the modulus of bnr (and the infinite places), 3: return also the characters"},
{"bnrclass",0,(void*)bnrclass0,6,"GGD0,L,","bnrclass(bnf,ideal,{flag=0}): given a big number field as output by bnfinit (only) and an ideal or a 2-component row vector formed by an ideal and a list of R1 zeros or ones representing a module, finds the ray class group structure corresponding to this module. flag is optional, and can be 0: default, 1: compute data necessary for working in the ray class group, for example with functions such as bnrisprincipal or bnrdisc, without computing the generators of the ray class group, or 2: with the generators. When flag=1 or 2, the fifth component is the ray class group structure obtained when flag=0"},
{"bnrclassno",1,(void*)bnrclassno,6,"GG","bnrclassno(bnf,x): ray class number of the module x for the big number field bnf. Faster than bnrclass if only the ray class number is wanted"},
{"bnrclassnolist",1,(void*)bnrclassnolist,6,"GG","bnrclassnolist(bnf,list): if list is as output by ideallist or similar, gives list of corresponding ray class numbers"},
{"bnrconductor",0,(void*)bnrconductor,6,"GDGDGDG","bnrconductor(a1,{a2},{a3},{flag=0}): conductor f of the subfield of the ray class field given by a1,a2,a3 (see bnrdisc). flag is optional and can be 0: default, 1: returns [f, Cl_f, H], H subgroup of the ray class group modulo f defining the extension, 2: returns [f, bnr(f), H]"},
{"bnrconductorofchar",1,(void*)bnrconductorofchar,6,"GG","bnrconductorofchar(bnr,chi): conductor of the character chi on the ray class group bnr"},
{"bnrdisc",0,(void*)bnrdisc0,6,"GDGDGD0,L,","bnrdisc(a1,{a2},{a3},{flag=0}): absolute or relative [N,R1,discf] of the field defined by a1,a2,a3. [a1,{a2},{a3}] is of type [bnr], [bnr,subgroup], [bnf, module] or [bnf,module,subgroup], where bnf is as output by bnfclassunit (with flag<=2), bnr by bnrclass (with flag>0), and subgroup is the HNF matrix of a subgroup of the corresponding ray class group (if omitted, the trivial subgroup). flag is optional whose binary digits mean 1: give relative data; 2: return 0 if module is not the conductor"},
{"bnrdisclist",0,(void*)bnrdisclist0,6,"GGDG","bnrdisclist(bnf,bound,{arch}): gives list of discriminants of ray class fields of all conductors up to norm bound, in a long vector The ramified Archimedean places are given by arch; all possible values are taken if arch is omitted. Supports the alternative syntax bnrdisclist(bnf,list), where list is as output by ideallist or ideallistarch (with units)"},
{"bnrinit",0,(void*)bnrinit0,6,"GGD0,L,","bnrinit(bnf,ideal,{flag=0}): given a big number field as output by bnfinit (only) and an ideal or a 2-component row vector formed by an ideal and a list of R1 zeros or ones representing a module, initializes data linked to the ray class group structure corresponding to this module. flag is optional, and can be 0: default (same as bnrclass with flag = 1), 1: compute also the generators (same as bnrclass with flag = 2). The fifth component is the ray class group structure"},
{"bnrisconductor",0,(void*)bnrisconductor,6,"lGDGDG","bnrisconductor(a1,{a2},{a3}): returns 1 if the modulus is the conductor of the subfield of the ray class field given by a1,a2,a3 (see bnrdisc), and 0 otherwise. Slightly faster than bnrconductor if this is the only desired result"},
{"bnrisprincipal",0,(void*)bnrisprincipal,6,"GGD1,L,","bnrisprincipal(bnr,x,{flag=1}): bnr being output by bnrinit, gives [v,alpha], where v is the vector of exponents on the class group generators and alpha is the generator of the resulting principal ideal. In particular x is principal if and only if v is the zero vector. If (optional) flag is set to 0, output only v"},
{"bnrrootnumber",0,(void*)bnrrootnumber,6,"GGD0,L,p","bnrrootnumber(bnr,chi,{flag=0}); returns the so-called Artin Root Number, i.e. the constant W appearing in the functional equation of the Hecke L-function associated to chi. Set flag = 1 if the character is known to be primitive"},
{"bnrstark",0,(void*)bnrstark,6,"GDGp","bnrstark(bnr,{subgroup}): bnr being as output by bnrinit(,,1), finds a relative equation for the class field corresponding to the module in bnr and the given congruence subgroup (the trivial subgroup if omitted) using Stark's units. The ground field and the class field must be totally real."},
{"break",0,(void*)break0,11,"D1,L,","break({n=1}): interrupt execution of current instruction sequence, and exit from the n innermost enclosing loops"},
{"ceil",1,(void*)gceil,2,"G","ceil(x): ceiling of x=smallest integer>=x"},
{"centerlift",0,(void*)centerlift0,2,"GDn","centerlift(x,{v}): centered lift of x. Same as lift except for integermods"},
{"changevar",1,(void*)changevar,2,"GG","changevar(x,y): change variables of x according to the vector y"},
{"charpoly",0,(void*)charpoly0,8,"GDnD0,L,","charpoly(A,{v=x},{flag=0}): det(v*Id-A)=characteristic polynomial of the matrix or polmod A. flag is optional and may be set to 1 (use Lagrange interpolation) or 2 (use Hessenberg form), 0 being the default"},
{"chinese",0,(void*)chinese,4,"GDG","chinese(x,{y}): x,y being both intmods (or polmods) computes z in the same residue classes as x and y"},
{"component",1,(void*)compo,2,"GL","component(x,s): the s'th component of the internal representation of x. For vectors or matrices, it is simpler to use x[]. For list objects such as nf, bnf, bnr or ell, it is much easier to use member functions starting with \".\""},
{"concat",0,(void*)concat,8,"GDG","concat(x,{y}): concatenation of x and y, which can be scalars, vectors or matrices, or lists (in this last case, both x and y have to be lists). If y is omitted, x has to be a list or row vector and its elements are concatenated"},
{"conj",1,(void*)gconj,2,"G","conj(x): the algebraic conjugate of x"},
{"conjvec",0,(void*)conjvec,2,"Gp","conjvec(x): conjugate vector of the algebraic number x"},
{"content",1,(void*)content,4,"G","content(x): gcd of all the components of x, when this makes sense"},
{"contfrac",0,(void*)contfrac0,4,"GDGD0,L,","contfrac(x,{b},{lmax}): continued fraction expansion of x (x rational,real or rational function). b and lmax are both optional, where b is the vector of numerators of the continued fraction, and lmax is a bound for the number of terms in the continued fraction expansion"},
{"contfracpnqn",1,(void*)pnqn,4,"G","contfracpnqn(x): [p_n,p_{n-1}; q_n,q_{n-1}] corresponding to the continued fraction x"},
{"core",0,(void*)core0,4,"GD0,L,","core(n,{flag=0}): unique (positive of negative) squarefree integer d dividing n such that n/d is a square. If (optional) flag is non-null, output the two-component row vector [d,f], where d is the unique squarefree integer dividing n such that n/d=f^2 is a square"},
{"coredisc",0,(void*)coredisc0,4,"GD0,L,","coredisc(n,{flag=0}): discriminant of the quadratic field Q(sqrt(n)). If (optional) flag is non-null, output a two-component row vector [d,f], where d is the discriminant of the quadratic field Q(sqrt(n)) and n=df^2. f may be a half integer"},
{"cos",0,(void*)gcos,3,"Gp","cos(x): cosine of x"},
{"cosh",0,(void*)gch,3,"Gp","cosh(x): hyperbolic cosine of x"},
{"cotan",0,(void*)gcotan,3,"Gp","cotan(x): cotangent of x"},
{"default",0,(void*)default0,11,"D\"\",r,D\"\",s,D0,L,","default({opt},{v}): returns the current value of the current default opt. If v is present, set opt to v first. If no argument is given, print a list of all defaults as well as their values."},
{"denominator",1,(void*)denom,2,"G","denominator(x): denominator of x (or lowest common denominator in case of an array)"},
{"deriv",0,(void*)deriv,7,"GDn","deriv(x,{y}): derivative of x with respect to the main variable of y, or to the main variable of x if y is omitted"},
{"dilog",0,(void*)dilog,3,"Gp","dilog(x): dilogarithm of x"},
{"dirdiv",1,(void*)dirdiv,4,"GG","dirdiv(x,y): division of the Dirichlet series x by the Dirichlet series y"},
{"direuler",0,(void*)direuler0,4,"V=GGEDG","direuler(p=a,b,expr,{c}): Dirichlet Euler product of expression expr from p=a to p=b, limited to b terms. Expr should be a polynomial or rational function in p and X, and X is understood to mean p^(-s). If c is present, output only the first c terms"},
{"dirmul",1,(void*)dirmul,4,"GG","dirmul(x,y): multiplication of the Dirichlet series x by the Dirichlet series y"},
{"dirzetak",1,(void*)dirzetak,6,"GG","dirzetak(nf,b): Dirichlet series of the Dedekind zeta function of the number field nf up to the bound b-1"},
{"divisors",1,(void*)divisors,4,"G","divisors(x): gives a vector formed by the divisors of x in increasing order"},
{"divrem",0,(void*)divrem,1,"GGDn","divrem(x,y,{v}): euclidean division of x by y giving as a 2-dimensional column vector the quotient and the remainder, with respect to v (to main variable if v is omitted)"},
{"eint1",0,(void*)veceint1,3,"GDGp","eint1(x,{n}): exponential integral E1(x). If n is present, computes the vector of the first n values of the exponential integral E1(n.x) (x > 0)"},
{"elladd",1,(void*)addell,5,"GGG","elladd(e,z1,z2): sum of the points z1 and z2 on elliptic curve e"},
{"ellak",1,(void*)akell,5,"GG","ellak(e,n): computes the n-th Fourier coefficient of the L-function of the elliptic curve e"},
{"ellan",1,(void*)anell,5,"GL","ellan(e,n): computes the first n Fourier coefficients of the L-function of the elliptic curve e (n<2^24 on a 32-bit machine)"},
{"ellap",0,(void*)ellap0,5,"GGD0,L,","ellap(e,p,{flag=0}): computes a_p for the elliptic curve e using Shanks-Mestre's method. flag is optional and can be set to 0 (default) or 1 (use Jacobi symbols)"},
{"ellbil",0,(void*)bilhell,5,"GGGp","ellbil(e,z1,z2): canonical bilinear form for the points z1,z2 on the elliptic curve e. Either z1 or z2 can also be a vector/matrix of points"},
{"ellchangecurve",1,(void*)coordch,5,"GG","ellchangecurve(x,y): change data on elliptic curve according to y=[u,r,s,t]"},
{"ellchangepoint",1,(void*)pointch,5,"GG","ellchangepoint(x,y): change data on point or vector of points x on an elliptic curve according to y=[u,r,s,t]"},
{"ellconvertname",1,(void*)ellconvertname,5,"G","ellconvertname(name): convert an elliptic curve name (as found in the elldata database) from a string to a triplet [conductor, isogeny class, index]. It will also convert a triplet back to a curve name."},
{"elleisnum",0,(void*)elleisnum,5,"GLD0,L,p","elleisnum(om,k,{flag=0}): om=[om1,om2] being a 2-component vector giving a basis of a lattice L and k an even positive integer, computes the numerical value of the Eisenstein series of weight k. When flag is non-zero and k=4 or 6, this gives g2 or g3 with the correct normalization"},
{"elleta",0,(void*)elleta,5,"Gp","elleta(om): om=[om1,om2], returns the two-component row vector [eta1,eta2] of quasi-periods associated to [om1,om2]"},
{"ellgenerators",1,(void*)ellgenerators,5,"G","ellgenerators(E): if E is an elliptic curve as output by ellinit(), return the generators of the Mordell-Weil group associated to the curve. This function depends on the curve being referenced in the elldata database."},
{"ellglobalred",1,(void*)ellglobalred,5,"G","ellglobalred(e): e being an elliptic curve, returns [N,[u,r,s,t],c], where N is the conductor of e, [u,r,s,t] leads to the standard model for e, and c is the product of the local Tamagawa numbers c_p"},
{"ellheight",0,(void*)ellheight0,5,"GGD2,L,p","ellheight(e,x,{flag=2}): canonical height of point x on elliptic curve E defined by the vector e. flag is optional and selects the algorithm used to compute the archimedean local height. Its meaning is 0: use theta-functions, 1: use Tate's method, 2: use Mestre's AGM"},
{"ellheightmatrix",0,(void*)mathell,5,"GGp","ellheightmatrix(e,x): gives the height matrix for vector of points x on elliptic curve e using theta functions"},
{"ellidentify",1,(void*)ellidentify,5,"G","ellidentify(E): look up the elliptic curve E in the elldata database and return [[N, M, ...], C] where N is the name of the curve in J. E. Cremona database, M the minimal model and C the coordinates change (see ellchangecurve)."},
{"ellinit",0,(void*)ellinit0,5,"GD0,L,p","ellinit(x,{flag=0}): x being the vector [a1,a2,a3,a4,a6] defining the curve Y^2 + a1.XY + a3.Y = X^3 + a2.X^2 + a4.X + a6, gives the vector: [a1,a2,a3,a4,a6,b2,b4,b6,b8,c4,c6,disc,j,[e1,e2,e3],w1,w2,eta1,eta2,area]. If the curve is defined over a p-adic field, the last six components are replaced by root,u^2,u,q,w,0. If optional flag is 1, omit them altogether. x can also be a string, in this case the coefficients of the curve with matching name are looked in the elldata database if available."},
{"ellisoncurve",1,(void*)ellisoncurve,5,"GG","ellisoncurve(e,x): true(1) if x is on elliptic curve e, false(0) if not"},
{"ellj",0,(void*)jell,5,"Gp","ellj(x): elliptic j invariant of x"},
{"elllocalred",1,(void*)elllocalred,5,"GG","elllocalred(e,p): e being an elliptic curve, returns [f,kod,[u,r,s,t],c], where f is the conductor's exponent, kod is the Kodaira type for e at p, [u,r,s,t] is the change of variable needed to make e minimal at p, and c is the local Tamagawa number c_p"},
{"elllseries",0,(void*)elllseries,5,"GGDGp","elllseries(e,s,{A=1}): L-series at s of the elliptic curve e, where A a cut-off point close to 1"},
{"ellminimalmodel",0,(void*)ellminimalmodel,5,"GD&","ellminimalmodel(e,{&v}): return the standard minimal integral model of the rational elliptic curve e. Sets v to the corresponding change of variables"},
{"ellorder",1,(void*)orderell,5,"GG","ellorder(e,p): order of the point p on the elliptic curve e over Q, 0 if non-torsion"},
{"ellordinate",0,(void*)ordell,5,"GGp","ellordinate(e,x): y-coordinates corresponding to x-ordinate x on elliptic curve e"},
{"ellpointtoz",0,(void*)zell,5,"GGp","ellpointtoz(e,P): lattice point z corresponding to the point P on the elliptic curve e"},
{"ellpow",1,(void*)powell,5,"GGG","ellpow(e,x,n): n times the point x on elliptic curve e (n in Z)"},
{"ellrootno",0,(void*)ellrootno,5,"lGDG","ellrootno(e,{p=1}): root number for the L-function of the elliptic curve e. p can be 1 (default), global root number, or a prime p (including 0) for the local root number at p"},
{"ellsearch",1,(void*)ellsearch,5,"G","ellsearch(N): if N is an integer, it is taken as a conductor else if N is a string, it can be a curve name (\"11a1\"), a isogeny class (\"11a\") or a conductor (\"11\"). Return all curves in the elldata database that match the  property."},
{"ellsigma",0,(void*)ellsigma,5,"GGD0,L,p","ellsigma(om,z,{flag=0}): om=[om1,om2], value of the Weierstrass sigma function of the lattice generated by om at z if flag = 0 (default). If flag = 1, arbitrary determination of the logarithm of sigma. If flag = 2 or 3, same but using the product expansion instead of theta series"},
{"ellsub",1,(void*)subell,5,"GGG","ellsub(e,z1,z2): difference of the points z1 and z2 on elliptic curve e"},
{"elltaniyama",0,(void*)elltaniyama,5,"GP","elltaniyama(e): modular parametrization of elliptic curve e"},
{"elltors",0,(void*)elltors0,5,"GD0,L,","elltors(e,{flag=0}): torsion subgroup of elliptic curve e: order, structure, generators. If flag = 0, use Doud's algorithm; if flag = 1, use Lutz-Nagell"},
{"ellwp",0,(void*)ellwp0,5,"GDGD0,L,pP","ellwp(e,{z=x},{flag=0}): Complex value of Weierstrass P function at z on the lattice generated over Z by e=[om1,om2] (e as given by ellinit is also accepted). Optional flag means 0 (default), compute only P(z), 1 compute [P(z),P'(z)], 2 consider om as an elliptic curve and compute P(z) for that curve (identical to ellztopoint in that case). If z is omitted or is a simple variable, return formal expansion in z"},
{"ellzeta",0,(void*)ellzeta,5,"GGp","ellzeta(om,z): om=[om1,om2], value of the Weierstrass zeta function of the lattice generated by om at z"},
{"ellztopoint",0,(void*)pointell,5,"GGp","ellztopoint(e,z): coordinates of point P on the curve e corresponding to the complex number z"},
{"erfc",0,(void*)gerfc,3,"Gp","erfc(x): complementary error function"},
{"error",0,(void*)error0,11,"vs*","error(\"msg\"): abort script with error message msg"},
{"eta",0,(void*)eta0,3,"GD0,L,p","eta(x,{flag=0}): if flag=0, eta function without the q^(1/24), otherwise eta of the complex number x in the upper half plane intelligently computed using SL(2,Z) transformations"},
{"eulerphi",1,(void*)gphi,4,"G","eulerphi(x): Euler's totient function of x"},
{"eval",1,(void*)geval,7,"G","eval(x): evaluation of x, replacing variables by their value"},
{"exp",0,(void*)gexp,3,"Gp","exp(x): exponential of x"},
{"factor",0,(void*)factor0,4,"GD-1,L,","factor(x,{lim}): factorization of x. lim is optional and can be set whenever x is of (possibly recursive) rational type. If lim is set return partial factorization, using primes up to lim (up to primelimit if lim=0)"},
{"factorback",0,(void*)factorback0,4,"GDGDG","factorback(f,{e},{nf}): given a factorisation f, gives the factored object back. If this is a prime ideal factorisation you must supply the corresponding number field as last argument. If e is present, f has to be a vector of the same length, and we return the product of the f[i]^e[i]"},
{"factorcantor",1,(void*)factcantor,4,"GG","factorcantor(x,p): factorization mod p of the polynomial x using Cantor-Zassenhaus"},
{"factorff",1,(void*)factorff,4,"GGG","factorff(x,p,a): factorization of the polynomial x in the finite field F_p[X]/a(X)F_p[X]"},
{"factorial",0,(void*)mpfactr,4,"Lp","factorial(x): factorial of x (x C-integer), the result being given as a real number"},
{"factorint",0,(void*)factorint,4,"GD0,L,","factorint(x,{flag=0}): factor the integer x. flag is optional, whose binary digits mean 1: avoid MPQS, 2: avoid first-stage ECM (may fall back on it later), 4: avoid Pollard-Brent Rho and Shanks SQUFOF, 8: skip final ECM (huge composites will be declared prime)"},
{"factormod",0,(void*)factormod0,4,"GGD0,L,","factormod(x,p,{flag=0}): factorization mod p of the polynomial x using Berlekamp. flag is optional, and can be 0: default or 1: simple factormod, same except that only the degrees of the irreducible factors are given"},
{"factornf",1,(void*)polfnf,6,"GG","factornf(x,t): factorization of the polynomial x over the number field defined by the polynomial t"},
{"factorpadic",0,(void*)factorpadic0,7,"GGLD0,L,","factorpadic(x,p,r,{flag=0}): p-adic factorization of the polynomial x to precision r. flag is optional and may be set to 0 (use round 4) or 1 (use Buchmann-Lenstra)"},
{"ffinit",0,(void*)ffinit,4,"GLDn","ffinit(p,n,{v=x}): monic irreducible polynomial of degree n over F_p[v]"},
{"fibonacci",1,(void*)fibo,4,"L","fibonacci(x): fibonacci number of index x (x C-integer)"},
{"floor",1,(void*)gfloor,2,"G","floor(x): floor of x = largest integer<=x"},
{"for",1,(void*)forpari,11,"vV=GGI","for(X=a,b,seq): the sequence is evaluated, X going from a up to b"},
{"fordiv",1,(void*)fordiv,11,"vGVI","fordiv(n,X,seq): the sequence is evaluated, X running over the divisors of n"},
{"forell",1,(void*)forell,11,"vVLLI","forell(E,a,b,seq): execute seq for each elliptic curves E of conductor between a and b in the elldata database."},
{"forprime",1,(void*)forprime,11,"vV=GGI","forprime(X=a,b,seq): the sequence is evaluated, X running over the primes between a and b"},
{"forstep",1,(void*)forstep,11,"vV=GGGI","forstep(X=a,b,s,seq): the sequence is evaluated, X going from a to b in steps of s (can be a vector of steps)"},
{"forsubgroup",0,(void*)forsubgroup,11,"vV=GDGI","forsubgroup(H=G,{bound},seq): execute seq for each subgroup H of the abelian group G (in SNF form), whose index is bounded by bound. H is given as a left divisor of G in HNF form"},
{"forvec",0,(void*)forvec,11,"vV=GID0,L,","forvec(x=v,seq,{flag=0}): v being a vector of two-component vectors of length n, the sequence is evaluated with x[i] going from v[i][1] to v[i][2] for i=n,..,1 if flag is zero or omitted. If flag = 1 (resp. flag = 2), restrict to increasing (resp. strictly increasing) sequences"},
{"frac",1,(void*)gfrac,2,"G","frac(x): fractional part of x = x-floor(x)"},
{"galoisexport",0,(void*)galoisexport,6,"GD0,L,","galoisexport(gal,{flag}): gal being a galois field as output by galoisinit, output a string representing the underlying permutation group in GAP notation (default) or Magma notation (flag = 1)"},
{"galoisfixedfield",0,(void*)galoisfixedfield,6,"GGD0,L,Dn","galoisfixedfield(gal,perm,{flag},{v=y}): gal being a galois field as output by galoisinit and perm an element of gal.group or a vector of such elements, return [P,x] such that P is a polynomial defining the fixed field of gal[1] by the subgroup generated by perm, and x is a root of P in gal expressed as a polmod in gal.pol. If flag is 1 return only P. If flag is 2 return [P,x,F] where F is the factorization of gal.pol over the field defined by P, where the variable v stands for a root of P"},
{"galoisidentify",1,(void*)galoisidentify,6,"G","galoisidentify(gal): gal being a galois field as output by galoisinit, output the isomorphism class of the underlying abstract group as a two-components vector [o,i], where o is the group order, and i is the group index in the GAP4 small group library"},
{"galoisinit",0,(void*)galoisinit,6,"GDG","galoisinit(pol,{den}): pol being a polynomial or a number field as output by nfinit defining a Galois extension of Q, compute the Galois group and all neccessary informations for computing fixed fields. den is optional and has the same meaning as in nfgaloisconj(,4)(see manual)"},
{"galoisisabelian",0,(void*)galoisisabelian,6,"GD0,L,","galoisisabelian(gal,{flag=0}): gal being as output by galoisinit, return 0 if gal is not abelian, the HNF matrix of gal over gal.gen if flag=0, 1 if flag is 1, and the SNF of gal is flag=2"},
{"galoispermtopol",1,(void*)galoispermtopol,6,"GG","galoispermtopol(gal,perm): gal being a galois field as output by galoisinit and perm a element of gal.group, return the polynomial defining the corresponding Galois automorphism"},
{"galoissubcyclo",0,(void*)galoissubcyclo,6,"GDGD0,L,Dn","galoissubcyclo(N,H,{fl=0},{v}):Compute a polynomial (in variable v) defining the subfield of Q(zeta_n) fixed by the subgroup H of (Z/nZ)*. N can be an integer n, znstar(n) or bnrinit(bnfinit(y),[n,[1]],1). H can be given by a generator, a set of generator given by a vector or a HNF matrix (see manual). If flag is 1, output only the conductor of the abelian extension. If flag is 2 output [pol,f] where pol is the polynomial and f the conductor."},
{"galoissubfields",0,(void*)galoissubfields,6,"GD0,L,Dn","galoissubfields(G,{flags=0},{v}):Output all the subfields of G. flags have the same meaning as for galoisfixedfield"},
{"galoissubgroups",1,(void*)galoissubgroups,6,"G","galoissubgroups(G):Output all the subgroups of G"},
{"gamma",0,(void*)ggamma,3,"Gp","gamma(x): gamma function at x"},
{"gammah",0,(void*)ggamd,3,"Gp","gammah(x): gamma of x+1/2 (x integer)"},
{"gcd",0,(void*)gcd0,4,"GDGD0,L,","gcd(x,{y}): greatest common divisor of x and y."},
{"getheap",0,(void*)getheap,11,"","getheap(): 2-component vector giving the current number of objects in the heap and the space they occupy"},
{"getrand",0,(void*)getrand,11,"l","getrand(): current value of random number seed"},
{"getstack",0,(void*)getstack,11,"l","getstack(): current value of stack pointer avma"},
{"gettime",0,(void*)gettime,11,"l","gettime(): time (in milliseconds) since last call to gettime"},
{"global",88,NULL,11,NULL,"global(x): declare x to be a global variable"},
{"hilbert",0,(void*)hil0,4,"lGGDG","hilbert(x,y,{p}): Hilbert symbol at p of x,y."},
{"hyperu",0,(void*)hyperu,3,"GGGp","hyperu(a,b,x): U-confluent hypergeometric function"},
{"idealadd",1,(void*)idealadd,6,"GGG","idealadd(nf,x,y): sum of two ideals x and y in the number field defined by nf"},
{"idealaddtoone",0,(void*)idealaddtoone0,6,"GGDG","idealaddtoone(nf,x,{y}): if y is omitted, when the sum of the ideals in the number field K defined by nf and given in the vector x is equal to Z_K, gives a vector of elements of the corresponding ideals who sum to 1. Otherwise, x and y are ideals, and if they sum up to 1, find one element in each of them such that the sum is 1"},
{"idealappr",0,(void*)idealappr0,6,"GGD0,L,","idealappr(nf,x,{flag=0}): x being a fractional ideal, gives an element b such that v_p(b)=v_p(x) for all prime ideals p dividing x, and v_p(b)>=0 for all other p. If (optional) flag is non-null x must be a prime ideal factorization with possibly zero exponents"},
{"idealchinese",1,(void*)idealchinese,6,"GGG","idealchinese(nf,x,y): x being a prime ideal factorization and y a vector of elements, gives an element b such that v_p(b-y_p)>=v_p(x) for all prime ideals p dividing x, and v_p(b)>=0 for all other p"},
{"idealcoprime",1,(void*)idealcoprime,6,"GGG","idealcoprime(nf,x,y): gives an element b in nf such that b. x is an integral ideal coprime to the integral ideal y"},
{"idealdiv",0,(void*)idealdiv0,6,"GGGD0,L,","idealdiv(nf,x,y,{flag=0}): quotient x/y of two ideals x and y in HNF in the number field nf. If (optional) flag is non-null, the quotient is supposed to be an integral ideal (slightly faster)"},
{"idealfactor",1,(void*)idealfactor,6,"GG","idealfactor(nf,x): factorization of the ideal x given in HNF into prime ideals in the number field nf"},
{"idealhnf",0,(void*)idealhnf0,6,"GGDG","idealhnf(nf,a,{b}): hermite normal form of the ideal a in the number field nf, whatever form a may have. If called as idealhnf(nf,a,b), the ideal is given as aZ_K+bZ_K in the number field K defined by nf"},
{"idealintersect",1,(void*)idealintersect,6,"GGG","idealintersect(nf,x,y): intersection of two ideals x and y in the number field defined by nf"},
{"idealinv",1,(void*)idealinv,6,"GG","idealinv(nf,x,{flag=0}): inverse of the ideal x in the number field nf. If flag is omitted or set to 0, use the different. If flag is 1 do not use it"},
{"ideallist",0,(void*)ideallist0,6,"GLD4,L,","ideallist(nf,bound,{flag=4}): vector of vectors L of all idealstar of all ideals of norm<=bound. If (optional) flag is present, its binary digits are toggles meaning 1: give generators; 2: add units; 4: give only the ideals and not the bid."},
{"ideallistarch",1,(void*)ideallistarch,6,"GGG","ideallistarch(nf,list,arch): list is a vector of vectors of of bid's as output by ideallist. Return a vector of vectors with the same number of components as the original list. The leaves give information about moduli whose finite part is as in original list, in the same order, and archimedean part is now arch. The information contained is of the same kind as was present in the input."},
{"ideallog",1,(void*)zideallog,6,"GGG","ideallog(nf,x,bid): if bid is a big ideal, as given by idealstar(nf,I,1) or idealstar(nf,I,2), gives the vector of exponents on the generators bid[2][3] (even if these generators have not been computed)"},
{"idealmin",0,(void*)minideal,6,"GGDGp","idealmin(nf,ix,{vdir}): minimum of the ideal ix in the direction vdir in the number field nf"},
{"idealmul",0,(void*)idealmul0,6,"GGGD0,L,p","idealmul(nf,x,y,{flag=0}): product of the two ideals x and y in the number field nf. If (optional) flag is non-nul, reduce the result"},
{"idealnorm",1,(void*)idealnorm,6,"GG","idealnorm(nf,x): norm of the ideal x in the number field nf"},
{"idealpow",0,(void*)idealpow0,6,"GGGD0,L,p","idealpow(nf,x,n,{flag=0}): n-th power of the ideal x in HNF in the number field nf If (optional) flag is non-null, reduce the result"},
{"idealprimedec",1,(void*)primedec,6,"GG","idealprimedec(nf,p): prime ideal decomposition of the prime number p in the number field nf as a vector of 5 component vectors [p,a,e,f,b] representing the prime ideals pZ_K+a. Z_K, e,f as usual, a as vector of components on the integral basis, b Lenstra's constant"},
{"idealprincipal",1,(void*)principalideal,6,"GG","idealprincipal(nf,x): returns the principal ideal generated by the algebraic number x in the number field nf"},
{"idealred",0,(void*)ideallllred,6,"GGDGp","idealred(nf,x,{vdir=0}): LLL reduction of the ideal x in the number field nf along direction vdir, in HNF"},
{"idealstar",0,(void*)idealstar0,6,"GGD1,L,","idealstar(nf,I,{flag=1}): gives the structure of (Z_K/I)^*. flag is optional, and can be 0: simply gives the structure as a 3-component vector v such that v[1] is the order (i.e. eulerphi(I)), v[2] is a vector of cyclic components, and v[3] is a vector giving the corresponding generators. If flag=1 (default), gives idealstarinit, i.e. a 6-component vector [I,v,fa,f2,U,V] where v is as above without the generators, fa is the prime ideal factorisation of I and f2, U and V are technical but essential to work in (Z_K/I)^*. Finally if flag=2, same as with flag=1 except that the generators are also given"},
{"idealtwoelt",0,(void*)ideal_two_elt0,6,"GGDG","idealtwoelt(nf,x,{a}): two-element representation of an ideal x in the number field nf. If (optional) a is non-zero, first element will be equal to a"},
{"idealval",1,(void*)idealval,6,"lGGG","idealval(nf,x,p): valuation at p given in idealprimedec format of the ideal x in the number field nf"},
{"ideleprincipal",0,(void*)principalidele,6,"GGp","ideleprincipal(nf,x): returns the principal idele generated by the algebraic number x in the number field nf"},
{"if",80,NULL,11,NULL,"if(a,seq1,seq2): if a is nonzero, seq1 is evaluated, otherwise seq2. seq1 and seq2 are optional, and if seq2 is omitted, the preceding comma can be omitted also"},
{"imag",1,(void*)gimag,2,"G","imag(x): imaginary part of x"},
{"incgam",0,(void*)incgam0,3,"GGDGp","incgam(s,x,{y}): incomplete gamma function. y is optional and is the precomputed value of gamma(s)"},
{"incgamc",0,(void*)incgamc,3,"GGp","incgamc(s,x): complementary incomplete gamma function"},
{"intcirc",0,(void*)intcirc0,9,"V=GGEDGp","intcirc(X=a,R,s,{tab}): numerical integration of s on the circle  |z-a|=R, divided by 2*I*Pi. tab is as in intnum."},
{"intformal",0,(void*)integ,7,"GDn","intformal(x,{y}): formal integration of x with respect to the main variable of y, or to the main variable of x if y is omitted"},
{"intfouriercos",0,(void*)intfourcos0,9,"V=GGGEDGp","intfouriercos(X=a,b,x,s,{tab}): numerical integration from a to b of cos(2*Pi*x*X)*s(X) from a to b, where a, b, and tab are as in intnum. This is the cosine-Fourier transform if a=-infty and b=+infty."},
{"intfourierexp",0,(void*)intfourexp0,9,"V=GGGEDGp","intfourierexp(X=a,b,x,s,{tab}): numerical integration from a to b of exp(-2*I*Pi*x*X)*s(X) from a to b, where a, b, and tab are as in intnum. This is the ordinary Fourier transform if a=-infty and b=+infty. Note the minus sign."},
{"intfouriersin",0,(void*)intfoursin0,9,"V=GGGEDGp","intfouriersin(X=a,b,x,s,{tab}): numerical integration from a to b of sin(2*Pi*x*X)*s(X) from a to b, where a, b, and tab are as in intnum. This is the sine-Fourier transform if a=-infty and b=+infty."},
{"intfuncinit",0,(void*)intfuncinit0,9,"V=GGED0,L,D0,L,p","intfuncinit(X=a,b,s,{flag=0},{m=0}): initialize tables for integrations  from a to b using a weight s(X). Essential for integral transforms such as intmellininv, intlaplaceinv and intfourier, since it avoids recomputing all the time the same quantities. Must then be used with intmellininvshort (for intmellininv) and directly with intnum and not with the corresponding  integral transforms for the others. See help for intnum for coding of a  and b, and m is as in intnuminit. If flag is nonzero, assumes that  s(-X)=conj(s(X)), which is twice faster."},
{"intlaplaceinv",0,(void*)intlaplaceinv0,9,"V=GGEDGp","intlaplaceinv(X=sig,x,s,{tab}): numerical integration on the line real(z) = sig of s(z)exp(xz)dz/(2*I*Pi), i.e. inverse Laplace transform of s at x. tab is as in intnum."},
{"intmellininv",0,(void*)intmellininv0,9,"V=GGEDGp","intmellininv(X=sig,x,s,{tab}): numerical integration on the  line real(z) = sig (or sig[1]) of s(z)x^(-z)dz/(2*I*Pi), i.e. inverse Mellin  transform of s at x. sig is coded as follows: either it is real, and then by default assume s(z) decreases like exp(-z). Or sig = [sigR, al], sigR is the abcissa of integration, and al = 0 for slowly decreasing functions, or al > 0 if s(z) decreases like exp(-al*z). tab is as in intnum. Use  intmellininvshort if several values must be computed."},
{"intmellininvshort",0,(void*)intmellininvshort,9,"GGGp","intmellininvshort(sig,x,tab): numerical integration on the  line real(z) = sig (or sig[1]) of s(z)x^(-z)dz/(2*I*Pi), i.e. inverse Mellin transform of s at x. sig is coded as follows: either it is real, and then by default assume s(z) decreases like exp(-z). Or sig = [sigR, al], sigR is the abcissa of integration, and al = 0 for slowly decreasing functions, or al > 0 if s(z) decreases like exp(-al*z). Compulsory table tab has been  precomputed using the command intfuncinit(t=[[-1],sig[2]],[[1],sig[2]],s)  (with possibly its two optional additional parameters), where sig[2] = 1 if not given. Orders of magnitude faster than intmellininv."},
{"intnum",0,(void*)intnum0,9,"V=GGEDGp","intnum(X=a,b,s,{tab}): numerical integration of s from a to b with  respect to X. a (and similarly b) is coded as follows. It can be a scalar: f is assumed to be C^infty at a. It can be a two component vector [a[1],a[2]], where a[1] is the scalar, and a[2] is the singularity exponent (in ]-1,0]), logs being neglected. It can be a one component vector [1] or [-1] meaning +infty or -infty, slowly decreasing functions. It can be a two component vector [[1], z] or [[-1], z], where [1] or [-1] indicates +infty or -infty and z is coded as follows. If z is zero, slowly decreasing. If z is real positive, exponentially decreasing, of the type exp(-zX). If z<-1, very slowly decreasing like X^(-z). If z is complex nonreal, real part is ignored and if z = r+I*s then if s>0, cosine oscillation exactly cos(sX), while if s<0, sine oscillation exactly sin(sX). If f is exponentially decreasing times oscillating function, you have a choice, but it is in general better to choose the oscillating part. Finally tab is either 0 (let the program choose  the integration step), a positive integer m (choose integration step 1/2^m), or a table tab precomputed with intnuminit (depending on the type of interval: compact, semi-compact or R, very slow, slow, exponential, or cosine or sine-oscillating decrease)."},
{"intnuminit",0,(void*)intnuminit,9,"GGD0,L,p","intnuminit(a,b,{m=0}): initialize tables for integrations from a to b. See help for intnum for coding of a and b. Possible types: compact interval, semi-compact (one extremity at + or - infinity) or R, and very slowly, slowly or exponentially decreasing, or sine or cosine oscillating at infinities,"},
{"intnuminitgen",0,(void*)intnuminitgen0,9,"VGGED0,L,D0,L,p","intnuminitgen(t,a,b,ph,{m=0},{flag=0}): initialize tables for  integrations from a to b using abcissas ph(t) and weights ph'(t). Note that  there is no equal sign after the variable name t since t always goes from  -infty to +infty, but it is ph(t) which goes from a to b, and this is not  checked. If flag = 1 or 2, multiply the reserved table length by 4^flag, to  avoid corresponding error."},
{"intnumromb",0,(void*)intnumromb0,9,"V=GGED0,L,p","intnumromb(X=a,b,s,{flag=0}): numerical integration of s (smooth in  ]a,b[) from a to b with respect to X. flag is optional and mean 0: default.  s can be evaluated exactly on [a,b]; 1: general function; 2: a or b can be  plus or minus infinity (chosen suitably), but of same sign; 3: s has only  limits at a or b"},
{"intnumstep",0,(void*)intnumstep,9,"lp","intnumstep(): gives the default value of m used by all intnum and sumnum  routines, such that the integration step is 1/2^m."},
{"isfundamental",1,(void*)gisfundamental,4,"G","isfundamental(x): true(1) if x is a fundamental discriminant (including 1), false(0) if not"},
{"ispower",0,(void*)ispower,4,"lGDGD&","ispower(x,{k},{&n}): true (1) if x is a k-th power, false (0) if not. If n is given and a k-th root was computed in the process, put that in n. If k is omitted, return the maximal k >= 2 such that x = n^k is a perfect power, or 0 if no such k exist."},
{"isprime",0,(void*)gisprime,4,"GD0,L,","isprime(x,{flag=0}): true(1) if x is a (proven) prime number, false(0) if not. If flag is 0 or omitted, use a combination of algorithms. If flag is 1, the primality is certified by the Pocklington-Lehmer Test. If flag is 2, the primality is certified using the APRCL test."},
{"ispseudoprime",0,(void*)gispseudoprime,4,"GD0,L,","ispseudoprime(x,{n}): true(1) if x is a strong pseudoprime, false(0) if not. If n is 0 or omitted, use BPSW test, otherwise use strong Rabin-Miller test for n randomly chosen bases"},
{"issquare",0,(void*)gissquarerem,4,"GD&","issquare(x,{&n}): true(1) if x is a square, false(0) if not. If n is given puts the exact square root there if it was computed"},
{"issquarefree",1,(void*)gissquarefree,4,"G","issquarefree(x): true(1) if x is squarefree, false(0) if not"},
{"kill",1,(void*)kill0,11,"vS","kill(x): kills the present value of the variable or function x. Returns new value or 0"},
{"kronecker",1,(void*)gkronecker,4,"GG","kronecker(x,y): kronecker symbol (x/y)"},
{"lcm",0,(void*)glcm0,4,"GDG","lcm(x,{y}): least common multiple of x and y, i.e. x*y / gcd(x,y)"},
{"length",1,(void*)glength,2,"lG","length(x): number of non code words in x, number of characters for a string"},
{"lex",1,(void*)lexcmp,1,"iGG","lex(x,y): compare x and y lexicographically (1 if x>y, 0 if x=y, -1 if x<y)"},
{"lift",0,(void*)lift0,2,"GDn","lift(x,{v}): lifts every element of Z/nZ to Z or T[x]/PT[x] to T[x] for a type T if v is omitted, otherwise lift only polymods with main variable v. If v does not occur in x, lift only intmods"},
{"lindep",0,(void*)lindep0,8,"GD0,L,p","lindep(x,{flag=0}): Z-linear dependencies between components of x. flag is optional, and can be 0: default, PSLQ; -1: using Hastad et al; -2: returns a non-trivial kernel vector (not integral in general); positive, and in that case should be between 0.5 and 1.0 times the accuracy in decimal digits of x, using a standard LLL"},
{"listcreate",1,(void*)listcreate,8,"L","listcreate(n): creates an empty list of maximum length n"},
{"listinsert",1,(void*)listinsert,8,"GGL","listinsert(list,x,n): insert x at index n in list, shifting the remaining elements to the right"},
{"listkill",1,(void*)listkill,8,"vG","listkill(list): kills list"},
{"listput",0,(void*)listput,8,"GGD0,L,","listput(list,x,{n}): sets n-th element of list equal to x. If n is omitted or greater than the current list length, just append x"},
{"listsort",0,(void*)listsort,8,"GD0,L,","listsort(list,{flag=0}): sort list in place. If flag is non-zero, suppress all but one occurence of each element in list"},
{"lngamma",0,(void*)glngamma,3,"Gp","lngamma(x): logarithm of the gamma function of x"},
{"log",0,(void*)glog,3,"Gp","log(x): natural logarithm of x."},
{"matadjoint",1,(void*)adj,8,"G","matadjoint(x): adjoint matrix of x"},
{"matalgtobasis",1,(void*)matalgtobasis,6,"GG","matalgtobasis(nf,x): nfalgtobasis applied to every element of the matrix x"},
{"matbasistoalg",1,(void*)matbasistoalg,6,"GG","matbasistoalg(nf,x): nfbasistoalg applied to every element of the matrix x"},
{"matcompanion",1,(void*)assmat,8,"G","matcompanion(x): companion matrix to polynomial x"},
{"matdet",0,(void*)det0,8,"GD0,L,","matdet(x,{flag=0}): determinant of the matrix x using Gauss-Bareiss. If (optional) flag is set to 1, use classical gaussian elimination (slightly better for integer entries)"},
{"matdetint",1,(void*)detint,8,"G","matdetint(x): some multiple of the determinant of the lattice generated by the columns of x (0 if not of maximal rank). Useful with mathnfmod"},
{"matdiagonal",1,(void*)diagonal,8,"G","matdiagonal(x): creates the diagonal matrix whose diagonal entries are the entries of the vector x"},
{"mateigen",0,(void*)eigen,8,"Gp","mateigen(x): eigenvectors of the matrix x given as columns of a matrix"},
{"matfrobenius",0,(void*)matfrobenius,8,"GD0,L,Dn","matfrobenius(M,{flag},{v=x}): Return the Frobenius form of the square matrix M. If flag is 1, return only the elementary divisors as a vector of polynomials in the variable v. If flag is 2, return a two-components vector [F,B] where F is the Frobenius form and B is the basis change so that M=B^-1*F*B."},
{"mathess",1,(void*)hess,8,"G","mathess(x): Hessenberg form of x"},
{"mathilbert",1,(void*)mathilbert,8,"L","mathilbert(n): Hilbert matrix of order n (n C-integer)"},
{"mathnf",0,(void*)mathnf0,8,"GD0,L,","mathnf(A,{flag=0}): (upper triangular) Hermite normal form of A, basis for the lattice formed by the columns of A. flag is optional whose value range from 0 to 4 (0 if omitted), meaning : 0: naive algorithm. 1: Use Batut's algorithm. Output 2-component vector [H,U] such that H is the HNF of A, and U is a unimodular matrix such that AU=H. 3: Use Batut's algorithm. Output [H,U,P] where P is a permutation matrix such that P A U = H. 4: as 1, using a heuristic variant of LLL reduction along the way"},
{"mathnfmod",1,(void*)hnfmod,8,"GG","mathnfmod(x,d): (upper triangular) Hermite normal form of x, basis for the lattice formed by the columns of x, where d is a multiple of the non-zero determinant of this lattice"},
{"mathnfmodid",1,(void*)hnfmodid,8,"GG","mathnfmodid(x,d): (upper triangular) Hermite normal form of x concatenated with d times the identity matrix"},
{"matid",1,(void*)matid,8,"L","matid(n): identity matrix of order n (n C-integer)"},
{"matimage",0,(void*)matimage0,8,"GD0,L,","matimage(x,{flag=0}): basis of the image of the matrix x. flag is optional and can be set to 0 or 1, corresponding to two different algorithms"},
{"matimagecompl",1,(void*)imagecompl,8,"G","matimagecompl(x): vector of column indices not corresponding to the indices given by the function matimage"},
{"matindexrank",1,(void*)indexrank,8,"G","matindexrank(x): gives two extraction vectors (rows and columns) for the matrix x such that the extracted matrix is square of maximal rank"},
{"matintersect",1,(void*)intersect,8,"GG","matintersect(x,y): intersection of the vector spaces whose bases are the columns of x and y"},
{"matinverseimage",1,(void*)inverseimage,8,"GG","matinverseimage(x,y): an element of the inverse image of the vector y by the matrix x if one exists, the empty vector otherwise"},
{"matisdiagonal",1,(void*)isdiagonal,8,"lG","matisdiagonal(x): true(1) if x is a diagonal matrix, false(0) otherwise"},
{"matker",0,(void*)matker0,8,"GD0,L,","matker(x,{flag=0}): basis of the kernel of the matrix x. flag is optional, and may be set to 0: default; non-zero: x is known to have integral entries"},
{"matkerint",0,(void*)matkerint0,8,"GD0,L,","matkerint(x,{flag=0}): LLL-reduced Z-basis of the kernel of the matrix x with integral entries. flag is optional, and may be set to 0: default, uses a modified LLL, 1: uses matrixqz"},
{"matmuldiagonal",1,(void*)matmuldiagonal,8,"GG","matmuldiagonal(x,d): product of matrix x by diagonal matrix whose diagonal coefficients are those of the vector d, equivalent but faster than x*matdiagonal(d)"},
{"matmultodiagonal",1,(void*)matmultodiagonal,8,"GG","matmultodiagonal(x,y): product of matrices x and y, knowing that the result will be a diagonal matrix. Much faster than general multiplication in that case"},
{"matpascal",0,(void*)matqpascal,8,"LDG","matpascal(n,{q}): Pascal triangle of order n if q is omited. q-Pascal triangle otherwise"},
{"matrank",1,(void*)rank,8,"lG","matrank(x): rank of the matrix x"},
{"matrix",0,(void*)matrice,8,"GGDVDVDI","matrix(m,n,{X},{Y},{expr=0}): mXn matrix of expression expr, the row variable X going from 1 to m and the column variable Y going from 1 to n. By default, fill with 0s"},
{"matrixqz",1,(void*)matrixqz0,8,"GG","matrixqz(x,p): if p>=0, transforms the rational or integral mxn (m>=n) matrix x into an integral matrix with gcd of maximal determinants equal to 1 if p is equal to 0, not divisible by p otherwise. If p=-1, finds a basis of the intersection with Z^n of the lattice spanned by the columns of x. If p=-2, finds a basis of the intersection with Z^n of the Q-vector space spanned by the columns of x"},
{"matsize",1,(void*)matsize,8,"G","matsize(x): number of rows and columns of the vector/matrix x as a 2-vector"},
{"matsnf",0,(void*)matsnf0,8,"GD0,L,","matsnf(x,{flag=0}): Smith normal form (i.e. elementary divisors) of the matrix x, expressed as a vector d. Binary digits of flag mean 1: returns [u,v,d] where d=u*x*v, otherwise only the diagonal d is returned, 2: allow polynomial entries, otherwise assume x is integral, 4: removes all information corresponding to entries equal to 1 in d"},
{"matsolve",1,(void*)gauss,8,"GG","matsolve(M,B): gaussian solution of MX=B (M matrix, B column vector)"},
{"matsolvemod",0,(void*)matsolvemod0,8,"GGGD0,L,","matsolvemod(M,D,B,{flag=0}): one solution of system of congruences MX=B mod D (M matrix, B and D column vectors). If (optional) flag is non-null return all solutions"},
{"matsupplement",1,(void*)suppl,8,"G","matsupplement(x): supplement the columns of the matrix x to an invertible matrix"},
{"mattranspose",1,(void*)gtrans,8,"G","mattranspose(x): x~=transpose of x"},
{"max",1,(void*)gmax,1,"GG","max(x,y): maximum of x and y"},
{"min",1,(void*)gmin,1,"GG","min(x,y): minimum of x and y"},
{"minpoly",0,(void*)minpoly,8,"GDn","minpoly(A,{v=x}): minimal polynomial of the matrix or polmod A."},
{"modreverse",1,(void*)polymodrecip,6,"G","modreverse(x): reverse polymod of the polymod x, if it exists"},
{"moebius",1,(void*)gmu,4,"G","moebius(x): Moebius function of x"},
{"newtonpoly",1,(void*)newtonpoly,6,"GG","newtonpoly(x,p): Newton polygon of polynomial x with respect to the prime p"},
{"next",0,(void*)next0,11,"D1,L,","next({n=1}): interrupt execution of current instruction sequence, and start another iteration from the n-th innermost enclosing loops"},
{"nextprime",1,(void*)gnextprime,4,"G","nextprime(x): smallest pseudoprime >= x"},
{"nfalgtobasis",1,(void*)algtobasis,6,"GG","nfalgtobasis(nf,x): transforms the algebraic number x into a column vector on the integral basis nf.zk"},
{"nfbasis",0,(void*)nfbasis0,6,"GD0,L,DG","nfbasis(x,{flag=0},{p}): integral basis of the field Q[a], where a is a root of the polynomial x, using the round 4 algorithm. Second and third args are optional. Binary digits of flag mean 1: assume that no square of a prime>primelimit divides the discriminant of x, 2: use round 2 algorithm instead. If present, p provides the matrix of a partial factorization of the discriminant of x, useful if one wants only an order maximal at certain primes only"},
{"nfbasistoalg",1,(void*)basistoalg,6,"GG","nfbasistoalg(nf,x): transforms the column vector x on the integral basis into an algebraic number"},
{"nfdetint",1,(void*)nfdetint,6,"GG","nfdetint(nf,x): multiple of the ideal determinant of the pseudo generating set x"},
{"nfdisc",0,(void*)nfdiscf0,6,"GD0,L,DG","nfdisc(x,{flag=0},{p}): discriminant of the number field defined by the polynomial x using round 4. Optional args flag and p are as in nfbasis"},
{"nfeltdiv",1,(void*)element_div,6,"GGG","nfeltdiv(nf,a,b): element a/b in nf"},
{"nfeltdiveuc",1,(void*)nfdiveuc,6,"GGG","nfeltdiveuc(nf,a,b): gives algebraic integer q such that a-bq is small"},
{"nfeltdivmodpr",1,(void*)element_divmodpr,6,"GGGG","nfeltdivmodpr(nf,a,b,pr): element a/b modulo pr in nf, where pr is in modpr format (see nfmodprinit)"},
{"nfeltdivrem",1,(void*)nfdivrem,6,"GGG","nfeltdivrem(nf,a,b): gives [q,r] such that r=a-bq is small"},
{"nfeltmod",1,(void*)nfmod,6,"GGG","nfeltmod(nf,a,b): gives r such that r=a-bq is small with q algebraic integer"},
{"nfeltmul",1,(void*)element_mul,6,"GGG","nfeltmul(nf,a,b): element a. b in nf"},
{"nfeltmulmodpr",1,(void*)element_mulmodpr,6,"GGGG","nfeltmulmodpr(nf,a,b,pr): element a. b modulo pr in nf, where pr is in modpr format (see nfmodprinit)"},
{"nfeltpow",1,(void*)element_pow,6,"GGG","nfeltpow(nf,a,k): element a^k in nf"},
{"nfeltpowmodpr",1,(void*)element_powmodpr,6,"GGGG","nfeltpowmodpr(nf,a,k,pr): element a^k modulo pr in nf, where pr is in modpr format (see nfmodprinit)"},
{"nfeltreduce",1,(void*)element_reduce,6,"GGG","nfeltreduce(nf,a,id): gives r such that a-r is in the ideal id and r is small"},
{"nfeltreducemodpr",1,(void*)nfreducemodpr,6,"GGG","nfeltreducemodpr(nf,a,pr): element a modulo pr in nf, where pr is in modpr format (see nfmodprinit)"},
{"nfeltval",1,(void*)element_val,6,"lGGG","nfeltval(nf,a,pr): valuation of element a at the prime pr as output by idealprimedec"},
{"nffactor",1,(void*)nffactor,6,"GG","nffactor(nf,x): factor polynomial x in number field nf"},
{"nffactormod",1,(void*)nffactormod,6,"GGG","nffactormod(nf,pol,pr): factorize polynomial pol modulo prime ideal pr in number field nf"},
{"nfgaloisapply",1,(void*)galoisapply,6,"GGG","nfgaloisapply(nf,aut,x): Apply the Galois automorphism sigma (polynomial or polymod) to the object x (element or ideal) in the number field nf"},
{"nfgaloisconj",0,(void*)galoisconj0,6,"GD0,L,DGp","nfgaloisconj(nf,{flag=0},{den}): list of conjugates of a root of the polynomial x=nf.pol in the same number field. flag is optional (set to 0 by default), meaning 0: use combination of flag 4 and 1, always complete; 1: use nfroots; 2 : use complex numbers, LLL on integral basis (not always complete); 4: use Allombert's algorithm, complete if the field is Galois of degree <= 35 (see manual for detail). nf can be simply a polynomial with flag 0,2 and 4, meaning: 0: use combination of flag 4 and 2, not always complete (but a warning is issued when the list is not proven complete); 2 & 4: same meaning and restrictions. Note that only flag 4 can be applied to fields of large degrees (approx. >= 20)"},
{"nfhilbert",0,(void*)nfhilbert0,6,"lGGGDG","nfhilbert(nf,a,b,{p}): if p is omitted, global Hilbert symbol (a,b) in nf, that is 1 if X^2-aY^2-bZ^2 has a non-trivial solution (X,Y,Z) in nf, -1 otherwise. Otherwise compute the local symbol modulo the prime ideal p"},
{"nfhnf",1,(void*)nfhermite,6,"GG","nfhnf(nf,x): if x=[A,I], gives a pseudo-basis of the module sum A_jI_j"},
{"nfhnfmod",1,(void*)nfhermitemod,6,"GGG","nfhnfmod(nf,x,detx): if x=[A,I], and detx is a multiple of the ideal determinant of x, gives a pseudo-basis of the module sum A_jI_j"},
{"nfinit",0,(void*)nfinit0,6,"GD0,L,p","nfinit(pol,{flag=0}): pol being a nonconstant irreducible polynomial, gives the vector: [pol,[r1,r2],discf,index,[M,MC,T2,T,different] (see manual),r1+r2 first roots, integral basis, matrix of power basis in terms of integral basis, multiplication table of basis]. flag is optional and can be set to 0: default; 1: do not compute different; 2: first use polred to find a simpler polynomial; 3: outputs a two-element vector [nf,Mod(a,P)], where nf is as in 2 and Mod(a,P) is a polymod equal to Mod(x,pol) and P=nf.pol; 4: as 2 but use a partial polred; 5: is to 3 what 4 is to 2"},
{"nfisideal",1,(void*)isideal,6,"lGG","nfisideal(nf,x): true(1) if x is an ideal in the number field nf, false(0) if not"},
{"nfisincl",1,(void*)nfisincl,6,"GG","nfisincl(x,y): tests whether the number field x is isomorphic to a subfield of y (where x and y are either polynomials or number fields as output by nfinit). Return 0 if not, and otherwise all the isomorphisms. If y is a number field, a faster algorithm is used"},
{"nfisisom",1,(void*)nfisisom,6,"GG","nfisisom(x,y): as nfisincl but tests whether x is isomorphic to y"},
{"nfkermodpr",1,(void*)nfkermodpr,6,"GGG","nfkermodpr(nf,x,pr): kernel of the matrix x in Z_K/pr, where pr is in modpr format (see nfmodprinit)"},
{"nfmodprinit",1,(void*)nfmodprinit,6,"GG","nfmodprinit(nf,pr): transform the 5 element row vector pr representing a prime ideal into modpr format necessary for all operations mod pr in the number field nf (see manual for details about the format)"},
{"nfnewprec",0,(void*)nfnewprec,6,"Gp","nfnewprec(nf): transform the number field data nf into new data using the current (usually larger) precision"},
{"nfroots",0,(void*)nfroots,6,"DGG","nfroots({nf},pol): roots of polynomial pol belonging to nf (Q if omitted) without multiplicity"},
{"nfrootsof1",1,(void*)rootsof1,6,"G","nfrootsof1(nf): number of roots of unity and primitive root of unity in the number field nf"},
{"nfsnf",1,(void*)nfsmith,6,"GG","nfsnf(nf,x): if x=[A,I,J], outputs [c_1,...c_n] Smith normal form of x"},
{"nfsolvemodpr",1,(void*)nfsolvemodpr,6,"GGGG","nfsolvemodpr(nf,a,b,pr): solution of a*x=b in Z_K/pr, where a is a matrix and b a column vector, and where pr is in modpr format (see nfmodprinit)"},
{"nfsubfields",0,(void*)subfields0,6,"GDG","nfsubfields(nf,{d=0}): find all subfields of degree d of number field nf (all subfields if d is null or omitted). Result is a vector of subfields, each being given by [g,h], where g is an absolute equation and h expresses one of the roots of g in terms of the root x of the polynomial defining nf"},
{"norm",1,(void*)gnorm,2,"G","norm(x): norm of x"},
{"norml2",1,(void*)gnorml2,2,"G","norml2(x): square of the L2-norm of the vector x"},
{"numbpart",1,(void*)numbpart,4,"G","numbpart(x): number of partitions of x"},
{"numdiv",1,(void*)gnumbdiv,4,"G","numdiv(x): number of divisors of x"},
{"numerator",1,(void*)numer,2,"G","numerator(x): numerator of x"},
{"numtoperm",1,(void*)numtoperm,2,"LG","numtoperm(n,k): permutation number k (mod n!) of n letters (n C-integer)"},
{"omega",1,(void*)gomega,4,"G","omega(x): number of distinct prime divisors of x"},
{"padicappr",1,(void*)padicappr,7,"GG","padicappr(x,a): p-adic roots of the polynomial x congruent to a mod p"},
{"padicprec",1,(void*)padicprec,2,"lGG","padicprec(x,p): absolute p-adic precision of object x"},
{"permtonum",1,(void*)permtonum,2,"G","permtonum(vect): ordinal (between 1 and n!) of permutation vect"},
{"polcoeff",0,(void*)polcoeff0,7,"GLDn","polcoeff(x,s,{v}): coefficient of degree s of x, or the s-th component for vectors or matrices (for which it is simpler to use x[]). With respect to the main variable if v is omitted, with respect to the variable v otherwise"},
{"polcompositum",0,(void*)polcompositum0,6,"GGD0,L,","polcompositum(pol1,pol2,{flag=0}): vector of all possible compositums of the number fields defined by the polynomials pol1 and pol2. If (optional) flag is set (i.e non-null), output for each compositum, not only the compositum polynomial pol, but a vector [pol,al1,al2,k] where al1 (resp. al2) is a root of pol1 (resp. pol2) expressed as a polynomial modulo pol, and a small integer k such that al2+k*al1 is the chosen root of pol"},
{"polcyclo",0,(void*)cyclo,7,"LDn","polcyclo(n,{v=x}): n-th cyclotomic polynomial (in variable v)"},
{"poldegree",0,(void*)poldegree,7,"lGDn","poldegree(x,{v}): degree of the polynomial or rational function x with respect to main variable if v is omitted, with respect to v otherwise. For scalar x, return 0 is x is non-zero and a negative number otherwise"},
{"poldisc",0,(void*)poldisc0,7,"GDn","poldisc(x,{v}): discriminant of the polynomial x, with respect to main variable if v is omitted, with respect to v otherwise"},
{"poldiscreduced",1,(void*)reduceddiscsmith,7,"G","poldiscreduced(f): vector of elementary divisors of Z[a]/f'(a)Z[a], where a is a root of the polynomial f"},
{"polgalois",0,(void*)polgalois,6,"Gp","polgalois(x): Galois group of the polynomial x (see manual for group coding). Return [n, s, k, name] where n is the order, s the signature, k the index and name is the GAP4 name of the transitive group."},
{"polhensellift",1,(void*)polhensellift,7,"GGGL","polhensellift(x, y, p, e): lift the factorization y of x modulo p to a factorization modulo p^e using Hensel lift. The factors in y must be pairwise relatively prime modulo p"},
{"polinterpolate",0,(void*)polint,7,"GDGDGD&","polinterpolate(xa,{ya},{x},{&e}): polynomial interpolation at x according to data vectors xa, ya (ie return P such that P(xa[i]) = ya[i] for all i). If ya is omitter, return P such that P(i) = xa[i]. If present, e will contain an error estimate on the returned value"},
{"polisirreducible",1,(void*)gisirreducible,7,"G","polisirreducible(x): true(1) if x is an irreducible non-constant polynomial, false(0) if x is reducible or constant"},
{"pollead",0,(void*)pollead,7,"GDn","pollead(x,{v}): leading coefficient of polynomial or series x, or x itself if x is a scalar. Error otherwise. With respect to the main variable of x if v is omitted, with respect to the variable v otherwise"},
{"pollegendre",0,(void*)legendre,7,"LDn","pollegendre(n,{v=x}): legendre polynomial of degree n (n C-integer), in variable v"},
{"polrecip",1,(void*)polrecip,7,"G","polrecip(x): reciprocal polynomial of x"},
{"polred",0,(void*)polred0,6,"GD0,L,DG","polred(x,{flag=0},{p}): reduction of the polynomial x (gives minimal polynomials only). Second and third args are optional. The following binary digits of flag are significant 1: partial reduction, 2: gives also elements. p, if present, contains the complete factorization matrix of the discriminant"},
{"polredabs",0,(void*)polredabs0,6,"GD0,L,","polredabs(x,{flag=0}): a smallest generating polynomial of the number field for the T2 norm on the roots, with smallest index for the minimal T2 norm. flag is optional, whose binary digit mean 1: give the element whose characteristic polynomial is the given polynomial. 4: give all polynomials of minimal T2 norm (give only one of P(x) and P(-x)). 16: partial reduction"},
{"polredord",1,(void*)ordred,6,"G","polredord(x): reduction of the polynomial x, staying in the same order"},
{"polresultant",0,(void*)polresultant0,7,"GGDnD0,L,","polresultant(x,y,{v},{flag=0}): resultant of the polynomials x and y, with respect to the main variables of x and y if v is omitted, with respect to the variable v otherwise. flag is optional, and can be 0: default, assumes that the polynomials have exact entries (uses the subresultant algorithm), 1 for arbitrary polynomials, using Sylvester's matrix, or 2: using a Ducos's modified subresultant algorithm"},
{"polroots",0,(void*)roots0,7,"GD0,L,p","polroots(x,{flag=0}): complex roots of the polynomial x. flag is optional, and can be 0: default, uses Schonhage's method modified by Gourdon, or 1: uses a modified Newton method"},
{"polrootsmod",0,(void*)rootmod0,7,"GGD0,L,","polrootsmod(x,p,{flag=0}): roots mod p of the polynomial x. flag is optional, and can be 0: default, or 1: use a naive search, useful for small p"},
{"polrootspadic",1,(void*)rootpadic,7,"GGL","polrootspadic(x,p,r): p-adic roots of the polynomial x to precision r"},
{"polsturm",0,(void*)sturmpart,7,"lGDGDG","polsturm(x,{a},{b}): number of real roots of the polynomial x in the interval]a,b] (which are respectively taken to be -oo or +oo when omitted)"},
{"polsubcyclo",0,(void*)polsubcyclo,7,"LLDn","polsubcyclo(n,d,{v=x}): finds an equation (in variable v) for the d-th degree subfields of Q(zeta_n). Output is a polynomial or a vector of polynomials is there are several such fields, or none."},
{"polsylvestermatrix",1,(void*)sylvestermatrix,7,"GG","polsylvestermatrix(x,y): forms the sylvester matrix associated to the two polynomials x and y. Warning: the polynomial coefficients are in columns, not in rows"},
{"polsym",1,(void*)polsym,7,"GL","polsym(x,n): vector of symmetric powers of the roots of x up to n"},
{"poltchebi",0,(void*)tchebi,7,"LDn","poltchebi(n,{v=x}): Tchebitcheff polynomial of degree n (n C-integer), in variable v"},
{"poltschirnhaus",1,(void*)tschirnhaus,6,"G","poltschirnhaus(x): random Tschirnhausen transformation of the polynomial x"},
{"polylog",0,(void*)polylog0,3,"LGD0,L,p","polylog(m,x,{flag=0}): m-th polylogarithm of x. flag is optional, and can be 0: default, 1: D_m~-modified m-th polylog of x, 2: D_m-modified m-th polylog of x, 3: P_m-modified m-th polylog of x"},
{"polzagier",1,(void*)polzag,7,"LL","polzagier(n,m): Zagier's polynomials of index n,m"},
{"precision",0,(void*)precision0,2,"GD0,L,","precision(x,{n}): change the precision of x to be n (n C-integer). If n is omitted, output real precision of object x"},
{"precprime",1,(void*)gprecprime,4,"G","precprime(x): largest pseudoprime <= x, 0 if x<=1"},
{"prime",1,(void*)prime,4,"L","prime(n): returns the n-th prime (n C-integer)"},
{"primepi",1,(void*)primepi,4,"G","primepi(x): the prime counting function pi(x) = #{p <= x, p prime}."},
{"primes",1,(void*)primes,4,"L","primes(n): returns the vector of the first n primes (n C-integer)"},
{"print",0,(void*)print,11,"vs*","print(a): outputs a (in raw format) ending with newline"},
{"print1",0,(void*)print1,11,"vs*","print1(a): outputs a (in raw format) without ending with newline"},
{"printp",0,(void*)printp,11,"vs*","printp(a): outputs a (in beautified format) ending with newline"},
{"printp1",0,(void*)printp1,11,"vs*","printp1(a): outputs a (in beautified format) without ending with newline"},
{"printtex",0,(void*)printtex,11,"vs*","printtex(a): outputs a in TeX format"},
{"prod",0,(void*)produit,9,"V=GGEDG","prod(X=a,b,expr,{x=1}): x times the product (X runs from a to b) of expression"},
{"prodeuler",0,(void*)prodeuler0,9,"V=GGEp","prodeuler(X=a,b,expr): Euler product (X runs over the primes between a and b) of real or complex expression"},
{"prodinf",0,(void*)prodinf0,9,"V=GED0,L,p","prodinf(X=a,expr,{flag=0}): infinite product (X goes from a to infinity) of real or complex expression. flag can be 0 (default) or 1, in which case compute the product of the 1+expr instead"},
{"psi",0,(void*)gpsi,3,"Gp","psi(x): psi-function at x"},
{"qfbclassno",0,(void*)qfbclassno0,4,"GD0,L,","qfbclassno(x,{flag=0}): class number of discriminant x using Shanks's method by default. If (optional) flag is set to 1, use Euler products"},
{"qfbcompraw",1,(void*)compraw,4,"GG","qfbcompraw(x,y): Gaussian composition without reduction of the binary quadratic forms x and y"},
{"qfbhclassno",1,(void*)hclassno,4,"G","qfbhclassno(x): Hurwitz-Kronecker class number of x>0"},
{"qfbnucomp",1,(void*)nucomp,4,"GGG","qfbnucomp(x,y,l): composite of primitive positive definite quadratic forms x and y using nucomp and nudupl, where l=[|D/4|^(1/4)] is precomputed"},
{"qfbnupow",1,(void*)nupow,4,"GG","qfbnupow(x,n): n-th power of primitive positive definite quadratic form x using nucomp and nudupl"},
{"qfbpowraw",1,(void*)powraw,4,"GL","qfbpowraw(x,n): n-th power without reduction of the binary quadratic form x"},
{"qfbprimeform",0,(void*)primeform,4,"GGp","qfbprimeform(x,p): returns the prime form of discriminant x, whose first coefficient is p"},
{"qfbred",0,(void*)qfbred0,4,"GD0,L,DGDGDG","qfbred(x,{flag=0},{D},{isqrtD},{sqrtD}): reduction of the binary quadratic form x. All other args. are optional. D, isqrtD and sqrtD, if present, supply the values of the discriminant, floor(sqrt(D)) and sqrt(D) respectively. If D<0, its value is not used and all references to Shanks's distance hereafter are meaningless. flag can be any of 0: default, uses Shanks's distance function d; 1: use d, do a single reduction step; 2: do not use d; 3: do not use d, single reduction step."},
{"qfbsolve",1,(void*)qfbsolve,4,"GG","qfbsolve(Q,p): Return [x,y] so that Q(x,y)=p where Q is a binary quadratic form and p a prime number, or 0 if there is no solution."},
{"qfgaussred",1,(void*)sqred,8,"G","qfgaussred(x): square reduction of the (symmetric) matrix x (returns a square matrix whose i-th diagonal term is the coefficient of the i-th square in which the coefficient of the i-th variable is 1)"},
{"qfjacobi",0,(void*)jacobi,8,"Gp","qfjacobi(x): eigenvalues and orthogonal matrix of eigenvectors of the real symmetric matrix x"},
{"qflll",0,(void*)qflll0,8,"GD0,L,p","qflll(x,{flag=0}): LLL reduction of the vectors forming the matrix x (gives the unimodular transformation matrix). The columns of x must be linearly independent, unless specified otherwise below. flag is optional,  and can be 0: default, 1: assumes x is integral, columns may be dependent, 2: assumes x is integral, returns a partially reduced basis, 4: assumes x is  integral, returns [K,I] where K is the integer kernel of x and I the LLL reduced image, 5: same as 4 but x may have polynomial coefficients, 8: same as 0 but x may have polynomial coefficients"},
{"qflllgram",0,(void*)qflllgram0,8,"GD0,L,p","qflllgram(x,{flag=0}): LLL reduction of the lattice whose gram matrix is x (gives the unimodular transformation matrix). flag is optional and can be 0: default,1: lllgramint algorithm for integer matrices, 4: lllgramkerim giving the kernel and the LLL reduced image, 5: lllgramkerimgen same when the matrix has polynomial coefficients, 8: lllgramgen, same as qflllgram when the coefficients are polynomials"},
{"qfminim",0,(void*)qfminim0,8,"GDGDGD0,L,p","qfminim(x,{bound},{maxnum},{flag=0}): number of vectors of square norm <= bound, maximum norm and list of vectors for the integral and definite quadratic form x; minimal non-zero vectors if bound=0. flag is optional, and can be 0: default; 1: returns the first minimal vector found (ignore maxnum); 2: as 0 but uses a more robust, slower implementation, valid for non integral quadratic forms"},
{"qfperfection",1,(void*)perf,8,"G","qfperfection(a): rank of matrix of xx~ for x minimal vectors of a gram matrix a"},
{"qfrep",0,(void*)qfrep0,8,"GGD0,L,","qfrep(x,B,{flag=0}): vector of (half) the number of vectors of norms from 1 to B for the integral and definite quadratic form x. Binary digits of flag mean 1: count vectors of even norm from 1 to 2B, 2: return a t_VECSMALL instead of a t_VEC"},
{"qfsign",1,(void*)signat,8,"G","qfsign(x): signature of the symmetric matrix x"},
{"quadclassunit",0,(void*)quadclassunit0,4,"GD0,L,DGp","quadclassunit(D,{flag=0},{tech=[]}): compute the structure of the class group and the regulator of the quadratic field of discriminant D. If flag is non-null (and D>0), compute the narrow class group. See manual for the optional technical parameters"},
{"quaddisc",1,(void*)quaddisc,4,"G","quaddisc(x): discriminant of the quadratic field Q(sqrt(x))"},
{"quadgen",1,(void*)quadgen,4,"G","quadgen(x): standard generator of quadratic order of discriminant x"},
{"quadhilbert",0,(void*)quadhilbert,4,"GDGp","quadhilbert(D,{pq}): relative equation for the Hilbert class field of the quadratic field of discriminant D (which can also be a bnf). If D<0, pq (if supplied) is a 2-component vector [p,q], where p,q are the prime numbers needed for Schertz's method. In that case, return 0 if [p,q] not suitable."},
{"quadpoly",0,(void*)quadpoly0,4,"GDn","quadpoly(D,{v=x}): quadratic polynomial corresponding to the discriminant D, in variable v"},
{"quadray",0,(void*)quadray,4,"GGDGp","quadray(D,f,{lambda}): relative equation for the ray class field of conductor f for the quadratic field of discriminant D (which can also be a bnf). For D < 0, lambda (if supplied) is the technical element of bnf  necessary for Schertz's method. In that case, return 0 if lambda is not suitable."},
{"quadregulator",0,(void*)gregula,4,"Gp","quadregulator(x): regulator of the real quadratic field of discriminant x"},
{"quadunit",0,(void*)gfundunit,4,"Gp","quadunit(x): fundamental unit of the quadratic field of discriminant x where x must be positive"},
{"random",0,(void*)genrand,2,"DG","random({N=2^31}): random integer between 0 and N-1"},
{"readvec",0,(void*)gp_readvec_file,11,"D\"\",s,","readvec({filename}): create a vector whose components are the evaluation of all the expressions found in the input file filename"},
{"real",1,(void*)greal,2,"G","real(x): real part of x"},
{"removeprimes",0,(void*)removeprimes,4,"DG","removeprimes({x=[]}): remove primes in the vector x (with at most 100 components) from the prime table. x can also be a single integer. List the current extra primes if x is omitted"},
{"reorder",0,(void*)reorder,11,"DG","reorder({x=[]}): reorder the variables for output according to the vector x. If x is void or omitted, print the current list of variables"},
{"return",0,(void*)return0,11,"DG","return({x=0}): return from current subroutine with result x"},
{"rnfalgtobasis",1,(void*)rnfalgtobasis,6,"GG","rnfalgtobasis(rnf,x): relative version of nfalgtobasis, where rnf is a relative numberfield"},
{"rnfbasis",1,(void*)rnfbasis,6,"GG","rnfbasis(bnf,order): given an order as output by rnfpseudobasis or rnfsteinitz, gives either a basis of the order if it is free, or an n+1-element generating set"},
{"rnfbasistoalg",1,(void*)rnfbasistoalg,6,"GG","rnfbasistoalg(rnf,x): relative version of nfbasistoalg, where rnf is a relative numberfield"},
{"rnfcharpoly",0,(void*)rnfcharpoly,6,"GGGDn","rnfcharpoly(nf,T,alpha,{var=x}): characteristic polynomial of alpha over nf, where alpha belongs to the algebra defined by T over nf. Returns a polynomial in variable var (x by default)"},
{"rnfconductor",0,(void*)rnfconductor,6,"GGD0,L,","rnfconductor(bnf,polrel,{flag=0}): conductor of the Abelian extension of bnf defined by polrel. The result is [conductor,rayclassgroup,subgroup], where conductor is the conductor itself, rayclassgroup the structure of the corresponding full ray class group, and subgroup the HNF defining the norm group (Artin or Takagi group) on the given generators rayclassgroup[3]. If flag is non-zero, check that polrel indeed defines an Abelian extension"},
{"rnfdedekind",1,(void*)rnfdedekind,6,"GGG","rnfdedekind(nf,T,pr): relative Dedekind criterion over nf, applied to the order defined by a root of irreducible polynomial T, modulo the prime ideal pr. Returns [flag,basis,val], where basis is a pseudo-basis of the enlarged order, flag is 1 iff this order is pr-maximal, and val is the valuation in pr of the order discriminant"},
{"rnfdet",1,(void*)rnfdet,6,"GG","rnfdet(nf,order): given a pseudomatrix, compute its pseudodeterminant"},
{"rnfdisc",1,(void*)rnfdiscf,6,"GG","rnfdisc(nf,pol): given a pol with coefficients in nf, gives a 2-component vector [D,d], where D is the relative ideal discriminant, and d is the relative discriminant in nf^*/nf*^2"},
{"rnfeltabstorel",1,(void*)rnfelementabstorel,6,"GG","rnfeltabstorel(rnf,x): transforms the element x from absolute to relative representation"},
{"rnfeltdown",1,(void*)rnfelementdown,6,"GG","rnfeltdown(rnf,x): expresses x on the base field if possible; returns an error otherwise"},
{"rnfeltreltoabs",1,(void*)rnfelementreltoabs,6,"GG","rnfeltreltoabs(rnf,x): transforms the element x from relative to absolute representation"},
{"rnfeltup",1,(void*)rnfelementup,6,"GG","rnfeltup(rnf,x): expresses x (belonging to the base field) on the relative field"},
{"rnfequation",0,(void*)rnfequation0,6,"GGD0,L,","rnfequation(nf,pol,{flag=0}): given a pol with coefficients in nf, gives the absolute equation apol of the number field defined by pol. flag is optional, and can be 0: default, or non-zero, gives [apol,th], where th expresses the root of nf.pol in terms of the root of apol"},
{"rnfhnfbasis",1,(void*)rnfhnfbasis,6,"GG","rnfhnfbasis(bnf,order): given an order as output by rnfpseudobasis, gives either a true HNF basis of the order if it exists, zero otherwise"},
{"rnfidealabstorel",1,(void*)rnfidealabstorel,6,"GG","rnfidealabstorel(rnf,x): transforms the ideal x from absolute to relative representation"},
{"rnfidealdown",1,(void*)rnfidealdown,6,"GG","rnfidealdown(rnf,x): finds the intersection of the ideal x with the base field"},
{"rnfidealhnf",1,(void*)rnfidealhermite,6,"GG","rnfidealhnf(rnf,x): relative version of idealhnf, where rnf is a relative numberfield"},
{"rnfidealmul",1,(void*)rnfidealmul,6,"GGG","rnfidealmul(rnf,x,y): relative version of idealmul, where rnf is a relative numberfield"},
{"rnfidealnormabs",1,(void*)rnfidealnormabs,6,"GG","rnfidealnormabs(rnf,x): absolute norm of the ideal x"},
{"rnfidealnormrel",1,(void*)rnfidealnormrel,6,"GG","rnfidealnormrel(rnf,x): relative norm of the ideal x"},
{"rnfidealreltoabs",1,(void*)rnfidealreltoabs,6,"GG","rnfidealreltoabs(rnf,x): transforms the ideal x from relative to absolute representation"},
{"rnfidealtwoelt",1,(void*)rnfidealtwoelement,6,"GG","rnfidealtwoelt(rnf,x): relative version of idealtwoelt, where rnf is a relative numberfield"},
{"rnfidealup",1,(void*)rnfidealup,6,"GG","rnfidealup(rnf,x): lifts the ideal x (of the base field) to the relative field"},
{"rnfinit",0,(void*)rnfinitalg,6,"GGp","rnfinit(nf,pol): pol being a non constant irreducible polynomial defined over the number field nf, initializes a vector of data necessary for working in relative number fields (rnf functions). See manual for technical details"},
{"rnfisfree",1,(void*)rnfisfree,6,"lGG","rnfisfree(bnf,order): given an order as output by rnfpseudobasis or rnfsteinitz, outputs true (1) or false (0) according to whether the order is free or not"},
{"rnfisnorm",0,(void*)rnfisnorm,6,"GGD0,L,","rnfisnorm(T,x,{flag=0}): T is as output by rnfisnorminit applied to L/K. Tries to tell whether x is a norm from L/K. Returns a vector [a,b] where x=Norm(a)*b. Looks for a solution which is a S-integer, with S a list of places in K containing the ramified primes, generators of the class group of ext, as well as those primes dividing x. If L/K is Galois, omit flag, otherwise it is used to add more places to S: all the places above the primes p <= flag (resp. p | flag) if flag > 0 (resp. flag < 0). The answer is guaranteed (i.e x norm iff b=1) if L/K is Galois or, under GRH, if S contains all primes less than 12.log(disc(M))^2, where M is the normal closure of L/K"},
{"rnfisnorminit",0,(void*)rnfisnorminit,6,"GGD2,L,","rnfisnorminit(pol,polrel,{flag=2}): let K be defined by a root of pol, L/K the extension defined by polrel. Compute technical data needed by rnfisnorm to solve norm equations Nx = a, for x in L, and a in K. If flag=0, do not care whether L/K is Galois or not; if flag = 1, assume L/K is Galois; if flag = 2, determine whether L/K is Galois"},
{"rnfkummer",0,(void*)rnfkummer,6,"GDGD0,L,p","rnfkummer(bnr,{subgroup},{deg=0}): bnr being as output by bnrinit, finds a relative equation for the class field corresponding to the module in bnr and the given congruence subgroup (the ray class field if subgroup is omitted). deg can be zero (default), or positive, and in this case the output is the list of all relative equations of degree deg for the given bnr"},
{"rnflllgram",0,(void*)rnflllgram,6,"GGGp","rnflllgram(nf,pol,order): given a pol with coefficients in nf and an order as output by rnfpseudobasis or similar, gives [[neworder],U], where neworder is a reduced order and U is the unimodular transformation matrix"},
{"rnfnormgroup",1,(void*)rnfnormgroup,6,"GG","rnfnormgroup(bnr,polrel): norm group (or Artin or Takagi group) corresponding to the Abelian extension of bnr.bnf defined by polrel, where the module corresponding to bnr is assumed to be a multiple of the conductor. The result is the HNF defining the norm group on the given generators in bnr[5][3]"},
{"rnfpolred",0,(void*)rnfpolred,6,"GGp","rnfpolred(nf,pol): given a pol with coefficients in nf, finds a list of relative polynomials defining some subfields, hopefully simpler"},
{"rnfpolredabs",0,(void*)rnfpolredabs,6,"GGD0,L,","rnfpolredabs(nf,pol,{flag=0}): given a pol with coefficients in nf, finds a relative simpler polynomial defining the same field. Binary digits of flag mean: 1: return also the element whose characteristic polynomial is the given polynomial, 2: return an absolute polynomial, 16: partial reduction"},
{"rnfpseudobasis",1,(void*)rnfpseudobasis,6,"GG","rnfpseudobasis(nf,pol): given a pol with coefficients in nf, gives a 4-component vector [A,I,D,d] where [A,I] is a pseudo basis of the maximal order in HNF on the power basis, D is the relative ideal discriminant, and d is the relative discriminant in nf^*/nf*^2"},
{"rnfsteinitz",1,(void*)rnfsteinitz,6,"GG","rnfsteinitz(nf,order): given an order as output by rnfpseudobasis, gives [A,I,D,d] where (A,I) is a pseudo basis where all the ideals except perhaps the last are trivial"},
{"round",0,(void*)round0,2,"GD&","round(x,{&e}): take the nearest integer to all the coefficients of x. If e is present, do not take into account loss of integer part precision, and set e = error estimate in bits"},
{"serconvol",1,(void*)convol,7,"GG","serconvol(x,y): convolution (or Hadamard product) of two power series"},
{"serlaplace",1,(void*)laplace,7,"G","serlaplace(x): replaces the power series sum of a_n*x^n/n! by sum of a_n*x^n. For the reverse operation, use serconvol(x,exp(X))"},
{"serreverse",1,(void*)recip,7,"G","serreverse(x): reversion of the power series x"},
{"setintersect",1,(void*)setintersect,8,"GG","setintersect(x,y): intersection of the sets x and y"},
{"setisset",1,(void*)setisset,8,"lG","setisset(x): true(1) if x is a set (row vector with strictly increasing entries), false(0) if not"},
{"setminus",1,(void*)setminus,8,"GG","setminus(x,y): set of elements of x not belonging to y"},
{"setrand",1,(void*)setrand,11,"lL","setrand(n): reset the seed of the random number generator to n"},
{"setsearch",0,(void*)setsearch,8,"lGGD0,L,","setsearch(x,y,{flag=0}): looks if y belongs to the set x. If flag is 0 or omitted, returns 0 if it is not, otherwise returns the index j such that y==x[j]. If flag is non-zero, return 0 if y belongs to x, otherwise the index j where it should be inserted"},
{"setunion",1,(void*)setunion,8,"GG","setunion(x,y): union of the sets x and y"},
{"shift",1,(void*)gshift,1,"GL","shift(x,n): shift x left n bits if n>=0, right -n bits if n<0."},
{"shiftmul",1,(void*)gmul2n,1,"GL","shiftmul(x,n): multiply x by 2^n (n>=0 or n<0)"},
{"sigma",0,(void*)gsumdivk,4,"GD1,L,","sigma(x,{k=1}): sum of the k-th powers of the divisors of x. k is optional and if omitted is assumed to be equal to 1"},
{"sign",1,(void*)gsigne,1,"iG","sign(x): sign of x, of type integer, real or fraction"},
{"simplify",1,(void*)simplify,2,"G","simplify(x): simplify the object x as much as possible"},
{"sin",0,(void*)gsin,3,"Gp","sin(x): sine of x"},
{"sinh",0,(void*)gsh,3,"Gp","sinh(x): hyperbolic sine of x"},
{"sizebyte",1,(void*)taille2,2,"lG","sizebyte(x): number of bytes occupied by the complete tree of the object x"},
{"sizedigit",1,(void*)sizedigit,2,"lG","sizedigit(x): maximum number of decimal digits minus one of (the coefficients of) x"},
{"solve",0,(void*)zbrent0,9,"V=GGEp","solve(X=a,b,expr): real root of expression expr (X between a and b), where expr(a)*expr(b)<=0"},
{"sqr",1,(void*)gsqr,3,"G","sqr(x): square of x. NOT identical to x*x"},
{"sqrt",0,(void*)gsqrt,3,"Gp","sqrt(x): square root of x"},
{"sqrtint",1,(void*)racine,4,"G","sqrtint(x): integer square root of x (x integer)"},
{"sqrtn",0,(void*)gsqrtn,3,"GGD&p","sqrtn(x,n,{&z}): nth-root of x, n must be integer. If present, z is set to a suitable root of unity to recover all solutions. If it was not possible, z is set to zero"},
{"subgrouplist",0,(void*)subgrouplist0,6,"GDGD0,L,","subgrouplist(bnr,{bound},{flag=0}): bnr being as output by bnrinit or a list of cyclic components of a finite Abelian group G, outputs the list of subgroups of G (of index bounded by bound, if not omitted), given as HNF left divisors of the SNF matrix corresponding to G. If flag=0 (default) and bnr is as output by bnrinit, gives only the subgroups for which the modulus is the conductor"},
{"subst",1,(void*)gsubst,7,"GnG","subst(x,y,z): in expression x, replace the variable y by the expression z"},
{"substpol",1,(void*)gsubstpol,7,"GGG","substpol(x,y,z): in expression x, replace the polynomial y by the expression z, using remainder decomposition of x."},
{"substvec",1,(void*)gsubstvec,7,"GGG","substvec(x,v,w): in expression x, make a best effort to replace the variables v1,...,vn by the expression w1,...,wn"},
{"sum",0,(void*)somme,9,"V=GGEDG","sum(X=a,b,expr,{x=0}): x plus the sum (X goes from a to b) of expression expr"},
{"sumalt",0,(void*)sumalt0,9,"V=GED0,L,p","sumalt(X=a,expr,{flag=0}): Cohen-Villegas-Zagier's acceleration of alternating series expr, X starting at a. flag is optional, and can be 0: default, or 1: uses a slightly different method using Zagier's polynomials"},
{"sumdiv",1,(void*)divsum,9,"GVE","sumdiv(n,X,expr): sum of expression expr, X running over the divisors of n"},
{"suminf",0,(void*)suminf0,9,"V=GEp","suminf(X=a,expr): infinite sum (X goes from a to infinity) of real or complex expression expr"},
{"sumnum",0,(void*)sumnum0,9,"V=GGEDGD0,L,p","sumnum(X=a,sig,expr,{tab},{flag=0}): numerical summation of expr from  X = ceiling(a) to +infinity. sig is either a scalar or a two-component vector coding the function's decrease rate at infinity. It is assumed that the scalar part of sig is to the right of all poles of expr. If present, tab must be initialized by sumnuminit. If flag is nonzero, assumes that conj(expr(z)) = expr(conj(z))."},
{"sumnumalt",0,(void*)sumnumalt0,9,"V=GGEDGD0,L,p","sumnumalt(X=a,sig,s,{tab},{flag=0}): numerical summation of (-1)^X s from X = ceiling(a) to +infinity. Note that the (-1)^X must not be included. sig is either a scalar or a two-component vector coded as in intnum, and the  scalar part is larger than all the real parts of the poles of s. Uses intnum, hence tab is as in intnum. If flag is nonzero, assumes that the function to  be summed satisfies conj(f(z))=f(conj(z)), and then up to twice faster."},
{"sumnuminit",0,(void*)sumnuminit,9,"GD0,L,D1,L,p","sumnuminit(sig, {m=0}, {sgn=1}): initialize tables for numerical summation. sgn is 1 (in fact >= 0), the default, for sumnum (ordinary sums)  or -1 (in fact < 0) for sumnumalt (alternating sums). sig is as in sumnum and m is as in intnuminit."},
{"sumpos",0,(void*)sumpos0,9,"V=GED0,L,p","sumpos(X=a,expr,{flag=0}): sum of positive series expr, the formal variable X starting at a. flag is optional, and can be 0: default, or 1: uses a slightly different method using Zagier's polynomials"},
{"tan",0,(void*)gtan,3,"Gp","tan(x): tangent of x"},
{"tanh",0,(void*)gth,3,"Gp","tanh(x): hyperbolic tangent of x"},
{"taylor",0,(void*)tayl,7,"GnP","taylor(x,y): taylor expansion of x with respect to the main variable of y"},
{"teichmuller",1,(void*)teich,3,"G","teichmuller(x): teichmuller character of p-adic number x"},
{"theta",0,(void*)theta,3,"GGp","theta(q,z): Jacobi sine theta-function"},
{"thetanullk",0,(void*)thetanullk,3,"GLp","thetanullk(q,k): k'th derivative at z=0 of theta(q,z)"},
{"thue",0,(void*)thue,7,"GGDG","thue(tnf,a,{sol}): solve the equation P(x,y)=a, where tnf was created with thueinit(P), and sol, if present, contains the solutions of Norm(x)=a modulo units in the number field defined by P. If tnf was computed without assuming GRH (flag 1 in thueinit), the result is unconditional"},
{"thueinit",0,(void*)thueinit,7,"GD0,L,p","thueinit(P,{flag=0}): initialize the tnf corresponding to P, that will be used to solve Thue equations P(x,y) = some-integer. If flag is non-zero, certify the result unconditionnaly. Otherwise, assume GRH (much faster of course)"},
{"trace",1,(void*)gtrace,8,"G","trace(x): trace of x"},
{"trap",0,(void*)trap0,11,"D\"\",r,DIDI","trap({err}, {rec}, {seq}): try to execute seq, trapping error err (all of them if err ommitted); sequence rec is executed if the error occurs and is the result of the command. When seq is omitted, define rec as a default handler for error err (a break loop will be started if rec omitted). If rec is the empty string \"\" pop out the last default handler"},
{"truncate",0,(void*)trunc0,2,"GD&","truncate(x,{&e}): truncation of x; when x is a power series,take away the O(X^). If e is present, do not take into account loss of integer part precision, and set e = error estimate in bits"},
{"type",1,(void*)type0,11,"G","type(x): return the type of the GEN x."},
{"until",82,NULL,11,NULL,"until(a,seq): evaluate the expression sequence seq until a is nonzero"},
{"valuation",1,(void*)ggval,2,"lGG","valuation(x,p): valuation of x with respect to p"},
{"variable",1,(void*)gpolvar,2,"G","variable(x): main variable of object x. Gives p for p-adic x, error for scalars"},
{"vecextract",0,(void*)extract0,8,"GGDG","vecextract(x,y,{z}): extraction of the components of the matrix or vector x according to y and z. If z is omitted, y designs columns, otherwise y corresponds to rows and z to columns. y and z can be vectors (of indices), strings (indicating ranges as in \"1..10\") or masks (integers whose binary representation indicates the indices to extract, from left to right 1, 2, 4, 8, etc.)"},
{"vecmax",1,(void*)vecmax,1,"G","vecmax(x): maximum of the elements of the vector/matrix x"},
{"vecmin",1,(void*)vecmin,1,"G","vecmin(x): minimum of the elements of the vector/matrix x"},
{"vecsort",0,(void*)vecsort0,8,"GDGD0,L,","vecsort(x,{k},{flag=0}): sorts the vector of vectors (or matrix) x in ascending order, according to the value of its k-th component if k is not omitted. Binary digits of flag (if present) mean: 1: indirect sorting, return the permutation instead of the permuted vector, 2: sort using lexicographic order, 4: use descending instead of ascending order"},
{"vector",0,(void*)vecteur,8,"GDVDI","vector(n,{X},{expr=0}): row vector with n components of expression expr (X ranges from 1 to n). By default, fill with 0s"},
{"vectorsmall",0,(void*)vecteursmall,8,"GDVDI","vectorsmall(n,{X},{expr=0}): VECSMALL with n components of expression expr (X ranges from 1 to n) which must be small integers. By default, fill with 0s"},
{"vectorv",0,(void*)vvecteur,8,"GDVDI","vectorv(n,{X},{expr=0}): column vector with n components of expression expr (X ranges from 1 to n). By default, fill with 0s"},
{"weber",0,(void*)weber0,3,"GD0,L,p","weber(x,{flag=0}): One of Weber's f function of x. flag is optional, and can be 0: default, function f(x)=exp(-i*Pi/24)*eta((x+1)/2)/eta(x) such that (j=(f^24-16)^3/f^24), 1: function f1(x)=eta(x/2)/eta(x) such that (j=(f1^24+16)^3/f2^24), 2: function f2(x)=sqrt(2)*eta(2*x)/eta(x) such that (j=(f2^24+16)^3/f2^24)"},
{"while",81,NULL,11,NULL,"while(a,seq): while a is nonzero evaluate the expression sequence seq. Otherwise 0"},
{"write",1,(void*)write0,11,"vss*","write(filename,a): write the string expression a (same output as print) to filename"},
{"write1",1,(void*)write1,11,"vss*","write1(filename,a): write the string expression a (same output as print1) to filename"},
{"writebin",0,(void*)gpwritebin,11,"vsDG","writebin(filename,{x}): write x as a binary object to file filename. If x is omitted, write all session variables"},
{"writetex",1,(void*)writetex,11,"vss*","writetex(filename,a): write the string expression a (same format as print) to filename, in TeX format"},
{"zeta",0,(void*)gzeta,3,"Gp","zeta(s): Riemann zeta function at s with s a complex or a p-adic number"},
{"zetak",0,(void*)gzetakall,6,"GGD0,L,p","zetak(nfz,s,{flag=0}): Dedekind zeta function of the number field nfz at s, where nfz is the vector computed by zetakinit (NOT by nfinit) flag is optional, and can be 0: default, compute zetak, or non-zero: compute the lambdak function, i.e. with the gamma factors"},
{"zetakinit",0,(void*)initzeta,6,"Gp","zetakinit(x): compute number field information necessary to use zetak, where x is an irreducible polynomial"},
{"zncoppersmith",0,(void*)zncoppersmith,4,"GGGDG","zncoppersmith(P, N, X, {B=N}): finds all integers x0 with |x0| <= X such that  gcd(N, P(x0)) > B. X should be smaller than exp((log B)^2 / (deg(P) log N))."},
{"znlog",1,(void*)znlog,4,"GG","znlog(x,g): g as output by znprimroot (modulo a prime). Return smallest non-negative n such that g^n = x"},
{"znorder",0,(void*)znorder,4,"GDG","znorder(x,{o}): order of the integermod x in (Z/nZ)*. Optional o is assumed to be a multiple of the order."},
{"znprimroot",1,(void*)ggener,4,"G","znprimroot(n): returns a primitive root of n when it exists"},
{"znstar",1,(void*)znstar,4,"G","znstar(n): 3-component vector v, giving the structure of (Z/nZ)^*. v[1] is the order (i.e. eulerphi(n)), v[2] is a vector of cyclic components, and v[3] is a vector giving the corresponding generators"},
{NULL,0,NULL,0,NULL,NULL} /* sentinel */
};
